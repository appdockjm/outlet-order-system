<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Outlet Order Management System</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* All your existing CSS styles remain the same */
        :root {
            --primary: #3498db;
            --secondary: #2ecc71;
            --danger: #e74c3c;
            --warning: #f39c12;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --gray: #95a5a6;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: var(--dark);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary), var(--dark));
            color: white;
            padding: 20px 0;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .logo i {
            font-size: 2.5rem;
        }
        
        .logo h1 {
            font-size: 1.8rem;
            font-weight: 600;
        }
        
        .user-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .outlet-info {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 50px;
        }
        
        .login-container {
            max-width: 400px;
            margin: 100px auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .login-container h2 {
            text-align: center;
            margin-bottom: 20px;
            color: var(--dark);
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }
        
        .btn-sm {
            padding: 6px 12px;
            font-size: 0.9rem;
        }
        
        .btn-primary {
            background: var(--primary);
            color: white;
        }
        
        .btn-primary:hover {
            background: #2980b9;
        }
        
        .btn-success {
            background: var(--secondary);
            color: white;
        }
        
        .btn-success:hover {
            background: #27ae60;
        }
        
        .btn-warning {
            background: var(--warning);
            color: white;
        }
        
        .btn-warning:hover {
            background: #e67e22;
        }
        
        .btn-danger {
            background: var(--danger);
            color: white;
        }
        
        .btn-danger:hover {
            background: #c0392b;
        }
        
        .btn-info {
            background: #17a2b8;
            color: white;
        }
        
        .btn-info:hover {
            background: #138496;
        }
        
        .tabs {
            display: flex;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 30px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            flex-wrap: wrap;
        }
        
        .tab {
            flex: 1;
            text-align: center;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            min-width: 120px;
        }
        
        .tab.active {
            background: var(--primary);
            color: white;
        }
        
        .tab:hover:not(.active) {
            background: #f1f1f1;
        }
        
        .tab-content {
            display: none;
            background: white;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .search-container {
            position: relative;
            margin-bottom: 20px;
        }
        
        .search-input {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .suggestions-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 5px 5px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }
        
        .suggestion-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .suggestion-item:hover {
            background: #f5f5f5;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .data-table th, .data-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        .data-table th {
            background: #f8f9fa;
            font-weight: 600;
        }
        
        .data-table tr:hover {
            background: #f8f9fa;
        }
        
        .action-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .form-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .form-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .form-row .form-group {
            flex: 1;
            margin-bottom: 0;
        }
        
        cart-items {
            margin-bottom: 20px;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        
        cart-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #eee;
        }
        
        cart-item:last-child {
            border-bottom: none;
        }
        
        cart-item-details {
            flex: 1;
        }
        
        cart-item-name {
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        cart-item-quantity {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .quantity-input {
            width: 80px;
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
        }
        
        .remove-item {
            color: var(--danger);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
        }
        
        cart-summary {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .summary-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .summary-total {
            font-weight: 700;
            font-size: 1.2rem;
            border-top: 1px solid #ddd;
            padding-top: 10px;
            margin-top: 10px;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--gray);
        }
        
        .empty-state i {
            font-size: 4rem;
            margin-bottom: 20px;
            color: #ddd;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 5px;
            color: white;
            font-weight: 500;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateX(150%);
            transition: transform 0.5s ease;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification-success {
            background: var(--secondary);
        }
        
        .notification-error {
            background: var(--danger);
        }
        
        .unit-badge {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            background: #e1f0fa;
            color: var(--primary);
        }
        
        .orders-container {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 5px;
            margin-top: 20px;
        }
        
        .order-card {
            padding: 15px;
            border-bottom: 1px solid #eee;
            background: white;
        }
        
        .order-card:last-child {
            border-bottom: none;
        }
        
        .order-card:hover {
            background: #f9f9f9;
        }
        
        .order-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .order-id {
            font-weight: 600;
            color: var(--primary);
        }
        
        .order-date {
            color: var(--gray);
            font-size: 0.9rem;
        }
        
        .order-outlet {
            font-weight: 500;
        }
        
        .order-items {
            margin-top: 10px;
            font-size: 0.9rem;
            color: var(--gray);
        }
        
        .order-status {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .status-received {
            background: #d1ecf1;
            color: #0c5460;
        }      

        .status-pending {
            background: #fff3cd;
            color: #856404;
        }
        
        .status-completed {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .status-cancelled {
            background: #f8d7da;
            color: #721c24;
        }
        
        .role-badge {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            background: #e8f5e8;
            color: var(--secondary);
        }
        
        .sync-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.9rem;
            margin-bottom: 15px;
        }
        
        .sync-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .sync-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .sync-pending {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .pdf-preview {
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
            margin-top: 20px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .pdf-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #333;
        }
        
        .pdf-order-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        
        .pdf-items-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        
        .pdf-items-table th {
            background: #f8f9fa;
            padding: 10px;
            text-align: left;
            border-bottom: 2px solid #333;
        }
        
        .pdf-items-table td {
            padding: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        .pdf-footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
            color: #666;
        }
        
        .import-export-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .file-input {
            display: none;
        }
        
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 15px;
            }
            
            .form-row {
                flex-direction: column;
            }
            
            .action-buttons {
                flex-direction: column;
            }
            
            .tab {
                min-width: 100px;
            }
            
            .pdf-order-info {
                flex-direction: column;
                gap: 10px;
            }
            
            .import-export-buttons {
                flex-direction: column;
            }
        }

        .action-buttons button {
            pointer-events: auto !important;
            position: relative;
            z-index: 1;
        }

        .order-card {
            position: relative;
        }

        .order-card .action-buttons {
            position: relative;
            z-index: 2;
        }

        .status-completed {
            background: #d1ecf1;
            color: #0c5460;
        }

        .status-pending {
            background: #fff3cd;
            color: #856404;
        }

        .status-cancelled {
            background: #f8d7da;
            color: #721c24;
        }       
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        .action-buttons .btn-danger:disabled {
            background-color: #95a5a6;
            border-color: #95a5a6;
        }

    </style>
</head>
<body>
    <!-- Login Screen -->
    <div id="loginScreen" class="login-container">
        <h2><i class="fas fa-lock"></i> Outlet Order System Login</h2>
        <div class="form-group">
            <label for="username">Username</label>
            <input type="text" id="username" placeholder="Enter your username">
        </div>
        <div class="form-group">
            <label for="password">Password</label>
            <input type="password" id="password" placeholder="Enter your password">
        </div>
        <button class="btn btn-primary" id="loginBtn" style="width: 100%; justify-content: center;">
            <i class="fas fa-sign-in-alt"></i> Login
        </button>
        <div style="margin-top: 20px; font-size: 0.9rem; color: var(--gray); text-align: center;">
            <p>Default admin credentials: admin / admin123</p>
            <p>User credentials: user1 / user123 (Outlet A)</p>
        </div>
    </div>

    <!-- Main Application (Initially Hidden) -->
    <div id="appScreen" style="display: none;">
        <div class="container">
            <header>
                <div class="header-content">
                    <div class="logo">
                        <i class="fas fa-warehouse"></i>
                        <h1>Outlet Order Management</h1>
                    </div>
                    <div class="user-info">
                        <div class="outlet-info">
                            <i class="fas fa-store"></i>
                            <span id="currentOutlet">Outlet A</span>
                        </div>
                        <div class="user-details">
                            <span id="userName">User: John Doe</span>
                            <span id="userRole" class="role-badge" style="margin-left: 10px;">Admin</span>
                            <button class="btn btn-danger" id="logoutBtn" style="width: auto; padding: 8px 15px; margin-left: 15px;">
                                <i class="fas fa-sign-out-alt"></i> Logout
                            </button>
                        </div>
                    </div>
                </div>
            </header>
            
            <div class="tabs" id="mainTabs">
                <div class="tab active" data-tab="orders">Orders</div>
                <div class="tab" data-tab="cart">Cart <span id="cartCount">(0)</span></div>
                <!-- Admin-only tabs (hidden for regular users) -->
                <div id="adminTab1" class="tab" data-tab="items" style="display: none;">Items</div>
                <div id="adminTab2" class="tab" data-tab="outlets" style="display: none;">Outlets</div>
                <div id="adminTab3" class="tab" data-tab="admin" style="display: none;">Users</div>
            </div>
            
            <!-- Orders Tab (Visible to all users) -->
            <div class="tab-content active" id="orders-tab">
                <h2>Order Management</h2>
                <div class="sync-status" id="syncStatus" style="display: none;">
                    <i class="fas fa-sync"></i>
                    <span id="syncStatusText">Syncing with Supabase...</span>
                </div>
                <div class="action-buttons" style="margin-bottom: 20px;">
                    <button class="btn btn-primary" id="addOrderBtn">
                        <i class="fas fa-plus"></i> Create New Order
                    </button>
                    <button class="btn btn-info" id="syncOrdersBtn">
                        <i class="fas fa-sync"></i> Refresh Orders
                    </button>
                    <button class="btn btn-warning admin-only" id="checkDuplicatesBtn" style="display: none;">
                        <i class="fas fa-search"></i> Check Duplicates
                    </button>
                    <button class="btn btn-danger admin-only" id="removeDuplicatesBtn" style="display: none;">
                        <i class="fas fa-trash"></i> Remove Duplicates
                    </button>
                </div>
                
                <h3>Recent Orders</h3>
                <div class="orders-container" id="ordersContainer">
                    <!-- Orders will be dynamically added here -->
                </div>
            </div>
            
            <!-- Cart Tab (Visible to all users) -->
            <div class="tab-content" id="cart-tab">
                <h2>Quick Order Cart</h2>
                
                <div class="search-container">
                    <input type="text" id="itemSearch" class="search-input" placeholder="Start typing to search items...">
                    <div class="suggestions-list" id="itemSuggestions"></div>
                </div>
                
                <div class="cart-items" id="cartItems">
                    <!-- Cart items will be dynamically added here -->
                </div>
                
                <div class="cart-summary">
                    <div class="summary-row">
                        <span>Total Items:</span>
                        <span id="totalItems">0</span>
                    </div>
                    
                    <div class="action-buttons">
                        <button class="btn btn-danger" id="clearCart">
                            <i class="fas fa-trash"></i> Clear Cart
                        </button>
                        <button class="btn btn-success" id="confirmOrder">
                            <i class="fas fa-check"></i> Confirm Order
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Items Tab (Admin only) -->
            <div class="tab-content" id="items-tab">
                <h2>Item Management <span class="role-badge">Admin Only</span></h2>
                <div class="import-export-buttons">
                    <button class="btn btn-success" id="exportItemsBtn">
                        <i class="fas fa-file-export"></i> Export Items to Excel
                    </button>
                    <button class="btn btn-primary" id="importItemsBtn">
                        <i class="fas fa-file-import"></i> Import Items from Excel
                    </button>
                    <input type="file" id="importFileInput" class="file-input" accept=".xlsx, .xls">
                </div>
                <div class="action-buttons" style="margin-bottom: 20px;">
                    <button class="btn btn-primary" id="addItemBtn">
                        <i class="fas fa-plus"></i> Add New Item
                    </button>
                </div>
                
                <div class="form-container" id="itemForm" style="display: none;">
                    <h3 id="itemFormTitle">Add New Item</h3>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="itemName">Item Name</label>
                            <input type="text" id="itemName" placeholder="Enter item name">
                        </div>
                        <div class="form-group">
                            <label for="itemCategory">Category</label>
                            <input type="text" id="itemCategory" placeholder="Enter category">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="itemUnit">Unit</label>
                            <select id="itemUnit">
                                <option value="KGS">KGS</option>
                                <option value="PCS">PCS</option>
                            </select>
                        </div>
                        <div class="form-group" style="align-self: flex-end;">
                            <button class="btn btn-success" id="saveItemBtn">
                                <i class="fas fa-save"></i> Save Item
                            </button>
                            <button class="btn btn-danger" id="cancelItemBtn">
                                <i class="fas fa-times"></i> Cancel
                            </button>
                        </div>
                    </div>
                </div>
                
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Item Name</th>
                            <th>Category</th>
                            <th>Unit</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="itemsList">
                        <!-- Items will be dynamically added here -->
                    </tbody>
                </table>
            </div>
            
            <!-- Outlets Tab (Admin only) -->
            <div class="tab-content" id="outlets-tab">
                <h2>Outlet Management <span class="role-badge">Admin Only</span></h2>
                <div class="action-buttons" style="margin-bottom: 20px;">
                    <button class="btn btn-primary" id="addOutletBtn">
                        <i class="fas fa-plus"></i> Add New Outlet
                    </button>
                </div>
                
                <div class="form-container" id="outletForm" style="display: none;">
                    <h3 id="outletFormTitle">Add New Outlet</h3>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="outletName">Outlet Name</label>
                            <input type="text" id="outletName" placeholder="Enter outlet name">
                        </div>
                        <div class="form-group">
                            <label for="outletLocation">Location</label>
                            <input type="text" id="outletLocation" placeholder="Enter location">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group" style="align-self: flex-end;">
                            <button class="btn btn-success" id="saveOutletBtn">
                                <i class="fas fa-save"></i> Save Outlet
                            </button>
                            <button class="btn btn-danger" id="cancelOutletBtn">
                                <i class="fas fa-times"></i> Cancel
                            </button>
                        </div>
                    </div>
                </div>
                
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Outlet Name</th>
                            <th>Location</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="outletsList">
                        <!-- Outlets will be dynamically added here -->
                    </tbody>
                </table>
            </div>
            
            <!-- Admin Tab (Admin only) -->
            <div class="tab-content" id="admin-tab">
                <h2>User Management <span class="role-badge">Admin Only</span></h2>
                <div class="action-buttons" style="margin-bottom: 20px;">
                    <button class="btn btn-primary" id="addUserBtn">
                        <i class="fas fa-plus"></i> Add New User
                    </button>
                </div>
                
                <div class="form-container" id="userForm" style="display: none;">
                    <h3 id="userFormTitle">Add New User</h3>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="newUserName">Full Name</label>
                            <input type="text" id="newUserName" placeholder="Enter full name">
                        </div>
                        <div class="form-group">
                            <label for="newUserUsername">Username</label>
                            <input type="text" id="newUserUsername" placeholder="Enter username">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="newUserPassword">Password</label>
                            <input type="password" id="newUserPassword" placeholder="Enter password">
                        </div>
                        <div class="form-group">
                            <label for="newUserOutlet">Outlet</label>
                            <select id="newUserOutlet">
                                <!-- Outlets will be populated dynamically -->
                            </select>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group" style="align-self: flex-end;">
                            <button class="btn btn-success" id="saveUserBtn">
                                <i class="fas fa-save"></i> Save User
                            </button>
                            <button class="btn btn-danger" id="cancelUserBtn">
                                <i class="fas fa-times"></i> Cancel
                            </button>
                        </div>
                    </div>
                </div>
                
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Username</th>
                            <th>Outlet</th>
                            <th>Role</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="userList">
                        <!-- Users will be dynamically added here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <!-- PDF Modal -->
    <div id="pdfModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 20px; border-radius: 10px; max-width: 800px; width: 90%; max-height: 90vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h3>Order PDF Preview</h3>
                <button class="btn btn-danger" id="closePdfModal">
                    <i class="fas fa-times"></i> Close
                </button>
            </div>
            <div id="pdfPreviewContent">
                <!-- PDF preview will be rendered here -->
            </div>
            <div class="action-buttons" style="margin-top: 20px;">
                <button class="btn btn-primary" id="printPdfBtn">
                    <i class="fas fa-print"></i> Print
                </button>
                <button class="btn btn-success" id="downloadPdfBtn">
                    <i class="fas fa-download"></i> Download PDF
                </button>
                <button class="btn btn-info" id="sharePdfBtn">
                    <i class="fas fa-share"></i> Share
                </button>
            </div>
        </div>
    </div>
    
    <div class="notification" id="notification"></div>

    <script>
        // Supabase Configuration
        const SUPABASE_URL = 'https://ngeizewipkbpdooitxtu.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5nZWl6ZXdpcGticGRvb2l0eHR1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM3MTA0MzAsImV4cCI6MjA3OTI4NjQzMH0.fdRR6xOKPXBav-Xf7zRofTkJLgZ7yG6f6FdRgz4ob_U';
        
        // Initialize Supabase client
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Database simulation (for fallback)
        const database = {
            users: [
                { id: 1, name: "Admin User", username: "admin", password: "admin123", outletId: 0, role: "admin" },
                { id: 2, name: "John Smith", username: "user1", password: "user123", outletId: 1, role: "user" },
                { id: 3, name: "Sarah Johnson", username: "user2", password: "user123", outletId: 2, role: "user" }
            ],
            outlets: [
                { id: 1, name: "Downtown Store", location: "Downtown" },
                { id: 2, name: "Uptown Market", location: "Uptown" },
                { id: 3, name: "Westside Shop", location: "Westside" }
            ],
            items: [
                { id: 1, name: "Sugar", category: "Groceries", unit: "KGS" },
                { id: 2, name: "Rice", category: "Groceries", unit: "KGS" },
                { id: 3, name: "Flour", category: "Groceries", unit: "KGS" },
                { id: 4, name: "Soap", category: "Personal Care", unit: "PCS" },
                { id: 5, name: "Toothpaste", category: "Personal Care", unit: "PCS" },
                { id: 6, name: "Shampoo", category: "Personal Care", unit: "PCS" },
                { id: 7, name: "Notebook", category: "Stationery", unit: "PCS" },
                { id: 8, name: "Pen", category: "Stationery", unit: "PCS" }
            ],
            orders: [],
            cart: [],
            orderCounter: {
                1: 2,
                2: 2,
                3: 1
            },
            deletedOrders: [] 
        };

        // Load data from localStorage (fallback)
        function loadFromLocalStorage() {
            const savedOrders = localStorage.getItem('outletOrders');
            const savedCounter = localStorage.getItem('orderCounter');
            const savedItems = localStorage.getItem('outletItems');
            const savedOutlets = localStorage.getItem('outletOutlets');
            const savedUsers = localStorage.getItem('outletUsers');
            const savedDeletedOrders = localStorage.getItem('outletDeletedOrders');
            
            if (savedOrders) {
                database.orders = JSON.parse(savedOrders);
            }
            if (savedCounter) {
                database.orderCounter = JSON.parse(savedCounter);
            }
            if (savedItems) {
                database.items = JSON.parse(savedItems);
            }
            if (savedOutlets) {
                database.outlets = JSON.parse(savedOutlets);
            }
            if (savedUsers) {
                database.users = JSON.parse(savedUsers);
            }
            if (savedDeletedOrders) {
                database.deletedOrders = JSON.parse(savedDeletedOrders);
            }
        }

        // Save data to localStorage (fallback)
        function saveToLocalStorage() {
            localStorage.setItem('outletOrders', JSON.stringify(database.orders));
            localStorage.setItem('orderCounter', JSON.stringify(database.orderCounter));
            localStorage.setItem('outletItems', JSON.stringify(database.items));
            localStorage.setItem('outletOutlets', JSON.stringify(database.outlets));
            localStorage.setItem('outletUsers', JSON.stringify(database.users));
            localStorage.setItem('outletDeletedOrders', JSON.stringify(database.deletedOrders)); 
        }

        // Current user and application state
        let currentUser = null;
        let cart = [];
        let editingId = null;
        let currentOrderId = null;
        let currentPdfOrder = null;

        // DOM Elements
        const loginScreen = document.getElementById('loginScreen');
        const appScreen = document.getElementById('appScreen');
        const usernameInput = document.getElementById('username');
        const passwordInput = document.getElementById('password');
        const loginBtn = document.getElementById('loginBtn');
        const logoutBtn = document.getElementById('logoutBtn');
        const userName = document.getElementById('userName');
        const userRole = document.getElementById('userRole');
        const currentOutlet = document.getElementById('currentOutlet');
        const cartCount = document.getElementById('cartCount');
        const totalItems = document.getElementById('totalItems');
        const cartItems = document.getElementById('cartItems');
        const itemSearch = document.getElementById('itemSearch');
        const itemSuggestions = document.getElementById('itemSuggestions');
        const ordersContainer = document.getElementById('ordersContainer');
        const itemsList = document.getElementById('itemsList');
        const outletsList = document.getElementById('outletsList');
        const userList = document.getElementById('userList');
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const clearCartBtn = document.getElementById('clearCart');
        const confirmOrderBtn = document.getElementById('confirmOrder');
        const notification = document.getElementById('notification');
        const adminTab1 = document.getElementById('adminTab1');
        const adminTab2 = document.getElementById('adminTab2');
        const adminTab3 = document.getElementById('adminTab3');
        const addOrderBtn = document.getElementById('addOrderBtn');
        const syncOrdersBtn = document.getElementById('syncOrdersBtn');
        const syncStatus = document.getElementById('syncStatus');
        const syncStatusText = document.getElementById('syncStatusText');
        const pdfModal = document.getElementById('pdfModal');
        const pdfPreviewContent = document.getElementById('pdfPreviewContent');
        const closePdfModal = document.getElementById('closePdfModal');
        const printPdfBtn = document.getElementById('printPdfBtn');
        const downloadPdfBtn = document.getElementById('downloadPdfBtn');
        const sharePdfBtn = document.getElementById('sharePdfBtn');
        const exportItemsBtn = document.getElementById('exportItemsBtn');
        const importItemsBtn = document.getElementById('importItemsBtn');
        const importFileInput = document.getElementById('importFileInput');

        // Form elements
        const itemForm = document.getElementById('itemForm');
        const itemFormTitle = document.getElementById('itemFormTitle');
        const itemName = document.getElementById('itemName');
        const itemCategory = document.getElementById('itemCategory');
        const itemUnit = document.getElementById('itemUnit');
        const saveItemBtn = document.getElementById('saveItemBtn');
        const cancelItemBtn = document.getElementById('cancelItemBtn');
        const addItemBtn = document.getElementById('addItemBtn');

        const outletForm = document.getElementById('outletForm');
        const outletFormTitle = document.getElementById('outletFormTitle');
        const outletName = document.getElementById('outletName');
        const outletLocation = document.getElementById('outletLocation');
        const saveOutletBtn = document.getElementById('saveOutletBtn');
        const cancelOutletBtn = document.getElementById('cancelOutletBtn');
        const addOutletBtn = document.getElementById('addOutletBtn');

        const userForm = document.getElementById('userForm');
        const userFormTitle = document.getElementById('userFormTitle');
        const newUserName = document.getElementById('newUserName');
        const newUserUsername = document.getElementById('newUserUsername');
        const newUserPassword = document.getElementById('newUserPassword');
        const newUserOutlet = document.getElementById('newUserOutlet');
        const saveUserBtn = document.getElementById('saveUserBtn');
        const cancelUserBtn = document.getElementById('cancelUserBtn');
        const addUserBtn = document.getElementById('addUserBtn');

        // Initialize the app
        async function init() {
            console.log('=== Initializing app ===');
            
            loadFromLocalStorage();
            setupEventListeners();
            
            // Clean up old deleted order records
            cleanupDeletedOrders();
            
            // Preload data from Supabase on startup
            try {
                console.log('Preloading data from Supabase...');
                
                // Preload outlets
                const { data: outlets, error: outletsError } = await supabase
                    .from('outlets')
                    .select('*')
                    .order('name');
                    
                if (!outletsError && outlets) {
                    database.outlets = outlets;
                    console.log('Preloaded outlets from Supabase:', outlets.length);
                }
                
                // Preload users
                const { data: users, error: usersError } = await supabase
                    .from('users')
                    .select('*')
                    .order('name');
                    
                if (!usersError && users) {
                    database.users = users;
                    console.log('Preloaded users from Supabase:', users.length);
                }
                
                // Preload items (for admin)
                const { data: items, error: itemsError } = await supabase
                    .from('items')
                    .select('*')
                    .order('name');
                    
                if (!itemsError && items) {
                    database.items = items;
                    console.log('Preloaded items from Supabase:', items.length);
                }
                
                saveToLocalStorage();
                
            } catch (error) {
                console.error('Error preloading data:', error);
            }
        }

        async function login(username, password) {
            try {
                showSyncStatus('Authenticating...', 'pending');
                
                // Try Supabase first
                const { data, error } = await supabase
                    .from('users')
                    .select('*')
                    .eq('username', username)
                    .eq('password', password)
                    .single();
                
                if (error) {
                    console.error('Supabase login error:', error);
                    // Fallback to local database
                    const user = database.users.find(u => u.username === username && u.password === password);
                    
                    if (user) {
                        currentUser = user;
                        // Load fresh data from Supabase for other users
                        await loadUsersFromSupabase();
                        await loadOutletsForUser();
                        showApp();
                        showNotification(`Welcome, ${user.name}!`, 'success');
                        return true;
                    } else {
                        showNotification('Invalid username or password', 'error');
                        return false;
                    }
                }
                
                if (data) {
                    currentUser = data;
                    
                    // Load fresh data from Supabase for all tables
                    await loadUsersFromSupabase(); // Load all users
                    await loadOutletsForUser();
                    await loadItems(); // For admin
                    await loadOutlets(); // For admin
                    
                    showApp();
                    showNotification(`Welcome, ${data.name}!`, 'success');
                    return true;
                }
                
                showNotification('Invalid username or password', 'error');
                return false;
                
            } catch (error) {
                console.error('Login error:', error);
                // Fallback to local database
                const user = database.users.find(u => u.username === username && u.password === password);
                
                if (user) {
                    currentUser = user;
                    await loadOutletsForUser();
                    showApp();
                    showNotification(`Welcome, ${user.name}!`, 'success');
                    return true;
                } else {
                    showNotification('Invalid username or password', 'error');
                    return false;
                }
            }
        }

        // Function to load users from Supabase and update local storage
        async function loadUsersFromSupabase() {
            console.log('Loading users from Supabase...');
            
            try {
                const { data, error } = await supabase
                    .from('users')
                    .select('*')
                    .order('name');
                
                if (error) {
                    console.error('Error loading users from Supabase:', error);
                    return false;
                }
                
                if (data && data.length > 0) {
                    // Update local database
                    database.users = data;
                    saveToLocalStorage();
                    console.log('Updated local users from Supabase:', data.length);
                    return true;
                } else {
                    console.log('No users found in Supabase');
                    return false;
                }
                
            } catch (error) {
                console.error('Error in loadUsersFromSupabase:', error);
                return false;
            }
        }

        // Helper function to load outlets for the current user
        async function loadOutletsForUser() {
            console.log('Loading outlets for user...');
            console.log('User role:', currentUser.role);
            console.log('User outlet_id:', currentUser.outlet_id);
            
            try {
                // Always load outlets from Supabase to ensure fresh data
                await refreshOutlets();
                
                // For regular users, verify they have a valid outlet
                if (currentUser.role !== 'admin') {
                    const userOutlet = database.outlets.find(o => o.id === currentUser.outlet_id);
                    if (!userOutlet) {
                        console.error('User outlet not found:', currentUser.outlet_id);
                        console.log('Available outlets:', database.outlets);
                        showNotification('Warning: Your assigned outlet was not found. Using default outlet.', 'warning');
                        
                        // Assign first available outlet if user has none
                        if (database.outlets.length > 0 && (!currentUser.outlet_id || currentUser.outlet_id === null)) {
                            currentUser.outlet_id = database.outlets[0].id;
                            console.log('Assigned default outlet to user:', currentUser.outlet_id);
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading outlets for user:', error);
            }
        }

        // Function to fix users with null outlet_id
        async function fixUsersWithNullOutlets() {
            const usersWithNullOutlet = database.users.filter(user => 
                user.role === 'user' && (!user.outlet_id || user.outlet_id === null)
            );
            
            if (usersWithNullOutlet.length > 0 && database.outlets.length > 0) {
                console.log('Fixing users with null outlets:', usersWithNullOutlet);
                
                for (const user of usersWithNullOutlet) {
                    user.outlet_id = database.outlets[0].id;
                    await saveUser(user);
                    console.log(`Fixed outlet for user: ${user.username}`);
                }
                
                if (usersWithNullOutlet.length > 0) {
                    showNotification(`Fixed outlet assignments for ${usersWithNullOutlet.length} users`, 'info');
                }
            }
        }


        async function loadOrders() {
            try {
                showSyncStatus('Syncing orders...', 'pending');
                
                let localOrders = [...database.orders];
                let supabaseOrders = [];
                
                console.log('Starting loadOrders...');
                console.log('Local orders count:', localOrders.length);
                
                // Try to get orders from Supabase
                try {
                    const { data, error } = await supabase
                        .from('orders')
                        .select('*')
                        .order('created_at', { ascending: false });
                    
                    if (error) {
                        console.error('Supabase orders error:', error);
                        throw error;
                    }
                    
                    supabaseOrders = data || [];
                    console.log('Supabase orders fetched:', supabaseOrders.length);
                    
                } catch (supabaseError) {
                    console.error('Supabase connection failed:', supabaseError);
                    // Continue with local orders only
                    displayOrders(localOrders);
                    showSyncStatus(' Offline - using local orders only', 'error');
                    return;
                }
                
                // Merge orders with proper deletion filtering
                const mergedOrders = await mergeOrders(supabaseOrders, localOrders);
                
                console.log('Merged orders count:', mergedOrders.length);
                
                // Update local database with merged orders
                database.orders = mergedOrders;
                saveToLocalStorage();
                
                displayOrders(mergedOrders);
                showSyncStatus(' Orders synced successfully', 'success');
                
            } catch (error) {
                console.error('Error loading orders:', error);
                // Fallback to local storage
                displayOrders([...database.orders]);
                showSyncStatus(' Sync failed - using local orders', 'error');
            }
        }

        // Sync locally deleted orders to Supabase
        async function syncLocalDeletionsToSupabase() {
            if (!navigator.onLine) {
                console.log('Offline, cannot sync deletions');
                return;
            }
            
            const unsyncedDeletions = database.deletedOrders.filter(d => !d.synced);
            
            if (unsyncedDeletions.length === 0) {
                console.log('No unsynced deletions');
                return;
            }
            
            console.log('Syncing', unsyncedDeletions.length, 'local deletions to Supabase');
            
            for (const deletion of unsyncedDeletions) {
                try {
                    console.log('Syncing deletion:', deletion.order_id);
                    
                    // Mark as deleted in Supabase
                    const { error: markError } = await supabase
                        .from('deleted_orders')
                        .upsert({
                            order_id: deletion.order_id,
                            deleted_by_user_id: deletion.deleted_by_user_id,
                            deleted_at: deletion.deleted_at,
                            synced: true
                        }, {
                            onConflict: 'order_id'
                        });
                    
                    if (markError) {
                        console.error('Error syncing deletion to Supabase:', markError);
                        continue;
                    }
                    
                    // Delete from orders table in Supabase
                    const { error: deleteError } = await supabase
                        .from('orders')
                        .delete()
                        .eq('id', deletion.order_id);
                    
                    if (deleteError) {
                        console.error('Error deleting order from Supabase:', deleteError);
                        continue;
                    }
                    
                    // Mark as synced locally
                    const index = database.deletedOrders.findIndex(d => d.order_id === deletion.order_id);
                    if (index !== -1) {
                        database.deletedOrders[index].synced = true;
                    }
                    
                    console.log('Successfully synced deletion:', deletion.order_id);
                    
                } catch (error) {
                    console.error('Error processing deletion sync:', error);
                }
            }
            
            // Save updated sync status
            saveToLocalStorage();
            console.log('Local deletions sync complete');
        }

        async function mergeOrders(supabaseOrders, localOrders) {
            console.log('=== mergeOrders called ===');
            console.log('Supabase orders:', supabaseOrders.length);
            console.log('Local orders:', localOrders.length);
            console.log('Local deleted orders:', database.deletedOrders);
            
            try {
                // Get list of deleted orders from Supabase
                let supabaseDeletedIds = new Set();
                try {
                    const { data: supabaseDeletedOrders, error } = await supabase
                        .from('deleted_orders')
                        .select('order_id');
                    
                    if (!error && supabaseDeletedOrders) {
                        supabaseDeletedOrders.forEach(d => {
                            console.log('Supabase deleted order:', d.order_id);
                            supabaseDeletedIds.add(d.order_id);
                        });
                    }
                } catch (error) {
                    console.error('Error fetching deleted orders from Supabase:', error);
                }
                
                // Create Set of locally deleted order IDs
                const localDeletedIds = new Set();
                database.deletedOrders.forEach(d => {
                    console.log('Locally deleted order:', d.order_id);
                    localDeletedIds.add(d.order_id);
                });
                
                console.log('Supabase deleted IDs:', Array.from(supabaseDeletedIds));
                console.log('Local deleted IDs:', Array.from(localDeletedIds));
                
                // Filter out orders that were deleted in Supabase
                const filteredSupabaseOrders = supabaseOrders.filter(order => {
                    const isDeleted = supabaseDeletedIds.has(order.id);
                    if (isDeleted) {
                        console.log('Filtering out Supabase-deleted order:', order.id);
                    }
                    return !isDeleted;
                });
                
                console.log('Filtered Supabase orders:', filteredSupabaseOrders.length);
                
                // Filter local orders against local deletions
                const validLocalOrders = localOrders.filter(localOrder => {
                    const isLocallyDeleted = localDeletedIds.has(localOrder.id);
                    if (isLocallyDeleted) {
                        console.log('Filtering out locally deleted order:', localOrder.id);
                    }
                    return !isLocallyDeleted;
                });
                
                console.log('Valid local orders:', validLocalOrders.length);
                
                // Start with Supabase orders as base
                const merged = [...filteredSupabaseOrders];
                const seenIds = new Set(filteredSupabaseOrders.map(order => order.id));
                
                // Add valid local orders that don't exist in Supabase
                validLocalOrders.forEach(localOrder => {
                    if (!seenIds.has(localOrder.id)) {
                        // Also check if not deleted in Supabase
                        if (!supabaseDeletedIds.has(localOrder.id)) {
                            console.log('Adding local order to merge:', localOrder.id);
                            merged.push(localOrder);
                            seenIds.add(localOrder.id);
                            
                            // Upload to Supabase if not already there
                            uploadOrderToSupabase(localOrder);
                        }
                    }
                });
                
                // Also check for local orders that exist in Supabase but are marked as deleted locally
                // We need to delete them from Supabase
                localDeletedIds.forEach(deletedOrderId => {
                    if (!supabaseDeletedIds.has(deletedOrderId)) {
                        // This order is marked as deleted locally but not in Supabase
                        console.log('Need to sync local deletion to Supabase:', deletedOrderId);
                        
                        // Find the order in Supabase
                        const orderInSupabase = supabaseOrders.find(o => o.id === deletedOrderId);
                        if (orderInSupabase) {
                            console.log('Order exists in Supabase, need to delete it:', deletedOrderId);
                            // Delete from Supabase
                            deleteOrderFromSupabase(deletedOrderId);
                            
                            // Remove from merged array if it was added
                            const index = merged.findIndex(o => o.id === deletedOrderId);
                            if (index !== -1) {
                                merged.splice(index, 1);
                                console.log('Removed deleted order from merged array:', deletedOrderId);
                            }
                        }
                    }
                });
                
                console.log('Final merged orders:', merged.length);
                
                // Sort by date (newest first)
                merged.sort((a, b) => {
                    const dateA = a.created_at || a.createdAt || a.date;
                    const dateB = b.created_at || b.createdAt || b.date;
                    return new Date(dateB) - new Date(dateA);
                });
                
                return merged;
                
            } catch (error) {
                console.error('Error in mergeOrders:', error);
                // Fallback: use Supabase orders only
                return supabaseOrders || [];
            }
        }

        // Function to delete orders from Supabase
        async function deleteOrderFromSupabase(orderId) {
            try {
                console.log('Deleting order from Supabase:', orderId);
                
                // First, mark as deleted in deleted_orders table
                const { error: markError } = await supabase
                    .from('deleted_orders')
                    .upsert({
                        order_id: orderId,
                        deleted_by_user_id: currentUser.id,
                        deleted_at: new Date().toISOString(),
                        synced: true
                    }, {
                        onConflict: 'order_id'
                    });
                
                if (markError) {
                    console.error('Error marking order as deleted in Supabase:', markError);
                    return false;
                }
                
                // Then delete from orders table
                const { error: deleteError } = await supabase
                    .from('orders')
                    .delete()
                    .eq('id', orderId);
                
                if (deleteError) {
                    console.error('Error deleting order from Supabase orders table:', deleteError);
                    return false;
                }
                
                console.log('Successfully deleted order from Supabase:', orderId);
                return true;
                
            } catch (error) {
                console.error('Error in deleteOrderFromSupabase:', error);
                return false;
            }
        }

        // Function to upload local orders to Supabase
        async function uploadOrderToSupabase(order) {
            try {
                // Check if this order was marked as deleted
                if (database.deletedOrders.includes(order.id)) {
                    console.log(`Order ${order.id} was deleted locally, skipping upload`);
                    return false;
                }
                
                const orderData = {
                    id: order.id,
                    outlet_id: order.outletId || order.outlet_id,
                    date: order.date,
                    items: order.items,
                    status: order.status || 'pending',
                    created_at: order.createdAt || order.created_at || new Date().toISOString(),
                    updated_at: new Date().toISOString()
                };

                const { error } = await supabase
                    .from('orders')
                    .upsert(orderData);
                
                if (error) {
                    console.error('Error uploading order to Supabase:', error);
                    return false;
                }
                
                console.log(`Order ${order.id} uploaded to Supabase`);
                return true;
                
            } catch (error) {
                console.error('Error uploading order:', error);
                return false;
            }
        }

        // Clean up old deleted order records (optional)
        function cleanupDeletedOrders(daysToKeep = 7) {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);
            
            // This assumes you track when orders were deleted
            // If not, you can just limit the array size
            if (database.deletedOrders.length > 100) {
                // Keep only the last 100 deleted order IDs
                database.deletedOrders = database.deletedOrders.slice(-100);
                saveToLocalStorage();
            }
        }

        // Function to sync deleted orders when online
        async function syncDeletedOrders() {
            if (!navigator.onLine || database.deletedOrders.length === 0) {
                return;
            }
            
            console.log('Syncing deleted orders to Supabase...');
            const deletedOrdersToSync = [...database.deletedOrders];
            let successfulDeletions = 0;
            
            for (const orderId of deletedOrdersToSync) {
                try {
                    const success = await deleteOrderFromSupabase(orderId);
                    if (success) {
                        // Remove from tracking array after successful sync
                        database.deletedOrders = database.deletedOrders.filter(id => id !== orderId);
                        successfulDeletions++;
                    }
                } catch (error) {
                    console.error(`Error syncing deletion of order ${orderId}:`, error);
                }
            }
            
            if (successfulDeletions > 0) {
                saveToLocalStorage();
                console.log(`Successfully synced ${successfulDeletions} deletions to Supabase`);
            }
        }

        async function loadItems() {
            if (currentUser.role !== 'admin') return;
            
            try {
                let items = [];
                
                // Try Supabase first
                const { data, error } = await supabase
                    .from('items')
                    .select('*')
                    .order('name');
                
                if (error) {
                    console.error('Supabase items error:', error);
                    // Fallback to local storage
                    items = [...database.items];
                } else {
                    items = data || [];
                }
                
                displayItems(items);
                
            } catch (error) {
                console.error('Error loading items:', error);
                // Fallback to local storage
                displayItems([...database.items]);
            }
        }

        async function loadOutlets() {
            console.log('Loading outlets...');
            
            try {
                let outlets = [];
                
                // Always try Supabase first for fresh data
                const { data, error } = await supabase
                    .from('outlets')
                    .select('*')
                    .order('name');
                
                if (error) {
                    console.error('Supabase outlets error:', error);
                    // Fallback to local storage
                    outlets = [...database.outlets];
                } else {
                    outlets = data || [];
                    console.log('Loaded outlets from Supabase:', outlets.length);
                    
                    // Update local database with data from Supabase
                    database.outlets = outlets;
                    saveToLocalStorage();
                }
                
                console.log('Final outlets to display:', outlets);
                displayOutlets(outlets);
                
                return outlets;
                
            } catch (error) {
                console.error('Error loading outlets:', error);
                // Fallback to local storage
                console.log('Using local outlets due to error:', database.outlets);
                displayOutlets([...database.outlets]);
                return database.outlets;
            }
        }

        async function loadUsers() {
            console.log('=== loadUsers() called ===');
            
            if (currentUser.role !== 'admin') return;
            
            try {
                let users = [];
                
                // ALWAYS try Supabase first for fresh data
                const { data, error } = await supabase
                    .from('users')
                    .select('*')
                    .order('name');
                
                if (error) {
                    console.error('Supabase users error:', error);
                    // Fallback to local storage
                    users = [...database.users];
                } else {
                    users = data || [];
                    console.log('Loaded users from Supabase:', users.length);
                    
                    // CRITICAL: Update local database with Supabase data
                    database.users = users;
                    saveToLocalStorage(); // Save to localStorage so it persists
                }
                
                displayUsers(users);
                
            } catch (error) {
                console.error('Error loading users:', error);
                // Fallback to local storage
                displayUsers([...database.users]);
            }
        }

        // Enhanced saveOrder function to handle sync better
        async function saveOrder(order) {
            try {
                showSyncStatus('Saving order...', 'pending');
                
                const orderData = {
                    id: order.id,
                    outlet_id: order.outletId || order.outlet_id,
                    date: order.date,
                    items: order.items,
                    status: order.status || 'pending',
                    created_at: order.createdAt || order.created_at || new Date().toISOString(),
                    updated_at: new Date().toISOString()
                };

                // Save to Supabase first
                let supabaseSuccess = false;
                try {
                    const { error } = await supabase
                        .from('orders')
                        .upsert(orderData);
                    
                    if (error) {
                        throw error;
                    }
                    supabaseSuccess = true;
                    
                } catch (supabaseError) {
                    console.error('Supabase save failed:', supabaseError);
                }
                
                // Always save to local storage
                const existingIndex = database.orders.findIndex(o => o.id === order.id);
                if (existingIndex !== -1) {
                    database.orders[existingIndex] = order;
                } else {
                    database.orders.push(order);
                }
                saveToLocalStorage();
                
                if (supabaseSuccess) {
                    showSyncStatus(' Order saved to cloud', 'success');
                } else {
                    showSyncStatus(' Order saved locally (offline)', 'warning');
                }
                
                return true;
                
            } catch (error) {
                console.error('Error saving order:', error);
                // Fallback to local storage
                const existingIndex = database.orders.findIndex(o => o.id === order.id);
                if (existingIndex !== -1) {
                    database.orders[existingIndex] = order;
                } else {
                    database.orders.push(order);
                }
                saveToLocalStorage();
                showSyncStatus(' Order saved locally', 'success');
                return true;
            }
        }

        // Enhanced deleteOrder function
        async function deleteOrder(orderId) {
            if (!confirm('Are you sure you want to delete this order?')) {
                return;
            }

            try {
                showSyncStatus('Deleting order...', 'pending');
                
                // First, try to mark as deleted in Supabase
                let supabaseSuccess = false;
                let supabaseError = null;
                
                try {
                    const deletionRecord = {
                        order_id: orderId,
                        deleted_by_user_id: currentUser.id,
                        deleted_at: new Date().toISOString(),
                        synced: true
                    };
                    
                    const { error } = await supabase
                        .from('deleted_orders')
                        .upsert(deletionRecord, {
                            onConflict: 'order_id'
                        });
                    
                    if (error) {
                        supabaseError = error;
                        console.error('Error marking order as deleted in Supabase:', error);
                        
                        // If it's an RLS error, try a different approach
                        if (error.code === '42501') {
                            console.log('RLS error detected, trying alternative...');
                            // Store locally and sync later
                            await storeDeletionLocally(orderId);
                        } else {
                            throw error;
                        }
                    } else {
                        supabaseSuccess = true;
                        console.log('Order marked as deleted in Supabase');
                    }
                    
                } catch (error) {
                    console.error('Supabase delete failed:', error);
                    // Store locally for later sync
                    await storeDeletionLocally(orderId);
                }
                
                // Always delete from local orders
                const index = database.orders.findIndex(o => o.id === orderId);
                if (index !== -1) {
                    database.orders.splice(index, 1);
                    saveToLocalStorage();
                }
                
                loadOrders();
                
                if (supabaseSuccess) {
                    showSyncStatus(' Order deleted from cloud', 'success');
                    showNotification(`Order ${orderId} deleted successfully`, 'success');
                } else {
                    showSyncStatus(' Order deleted locally', 'warning');
                    showNotification(`Order ${orderId} deleted locally. ${supabaseError ? '(RLS policy issue)' : ''}`, 'warning');
                }
                
                // Clear cart if deleting active order
                if (currentOrderId === orderId) {
                    cart = [];
                    currentOrderId = null;
                    updateCart();
                }
                
            } catch (error) {
                console.error('Error deleting order:', error);
                showNotification('Error deleting order', 'error');
            }
        }

        // Helper function to store deletion locally
        async function storeDeletionLocally(orderId) {
            const deletionRecord = {
                order_id: orderId,
                deleted_by_user_id: currentUser.id,
                deleted_at: new Date().toISOString(),
                synced: false
            };
            
            // Remove any existing record for this order
            database.deletedOrders = database.deletedOrders.filter(d => d.order_id !== orderId);
            
            // Add new record
            database.deletedOrders.push(deletionRecord);
            saveToLocalStorage();
            
            console.log('Deletion stored locally for later sync:', orderId);
        }

        async function saveItem(item) {
            if (currentUser.role !== 'admin') return;
            
            try {
                // Try Supabase first
                const { error } = await supabase
                    .from('items')
                    .upsert({
                        id: item.id,
                        name: item.name,
                        category: item.category,
                        unit: item.unit
                    }, {
                        onConflict: 'id'
                    });
                
                if (error) {
                    console.error('Supabase save item error:', error);
                    // Fallback to local storage
                    const existingIndex = database.items.findIndex(i => i.id === item.id);
                    if (existingIndex !== -1) {
                        database.items[existingIndex] = item;
                    } else {
                        database.items.push(item);
                    }
                    saveToLocalStorage();
                } else {
                    console.log('Item saved to Supabase:', item);
                }
                
                return true;
                
            } catch (error) {
                console.error('Error saving item:', error);
                // Fallback to local storage
                const existingIndex = database.items.findIndex(i => i.id === item.id);
                if (existingIndex !== -1) {
                    database.items[existingIndex] = item;
                } else {
                    database.items.push(item);
                }
                saveToLocalStorage();
                return true;
            }
        }

        async function deleteItem(itemId) {
            if (currentUser.role !== 'admin') return;
            
            // Check if item is used in any orders
            const isItemInOrders = database.orders.some(order => 
                order.items && order.items.some(item => item.id === itemId)
            );
            
            if (isItemInOrders) {
                showNotification('Cannot delete item: It is used in existing orders', 'error');
                return;
            }
            
            try {
                // Try Supabase first
                const { error } = await supabase
                    .from('items')
                    .delete()
                    .eq('id', itemId);
                
                if (error) {
                    console.error('Supabase delete item error:', error);
                }
                
                // Remove from local storage regardless
                database.items = database.items.filter(i => i.id !== itemId);
                saveToLocalStorage();
                loadItems();
                showNotification('Item deleted successfully', 'success');
                
            } catch (error) {
                console.error('Error deleting item:', error);
                // Fallback to local storage
                database.items = database.items.filter(i => i.id !== itemId);
                saveToLocalStorage();
                loadItems();
                showNotification('Item deleted successfully', 'success');
            }
        }

        async function saveOutlet(outlet) {
            if (currentUser.role !== 'admin') return;
            
            try {
                // Clean the outlet data before saving
                const cleanOutlet = {
                    id: outlet.id,
                    name: outlet.name.replace(/^['"](.*)['"]$/, '$1').trim(),
                    location: outlet.location.replace(/^['"](.*)['"]$/, '$1').trim()
                };
                
                // Try Supabase first
                const { error } = await supabase
                    .from('outlets')
                    .upsert(cleanOutlet);
                
                if (error) {
                    console.error('Supabase save outlet error:', error);
                    // Fallback to local storage
                    const existingIndex = database.outlets.findIndex(o => o.id === outlet.id);
                    if (existingIndex !== -1) {
                        database.outlets[existingIndex] = cleanOutlet;
                    } else {
                        database.outlets.push(cleanOutlet);
                    }
                    saveToLocalStorage();
                } else {
                    console.log('Outlet saved to Supabase:', cleanOutlet);
                }
                
                return true;
                
            } catch (error) {
                console.error('Error saving outlet:', error);
                // Fallback to local storage with cleaned data
                const cleanOutlet = {
                    id: outlet.id,
                    name: outlet.name.replace(/^['"](.*)['"]$/, '$1').trim(),
                    location: outlet.location.replace(/^['"](.*)['"]$/, '$1').trim()
                };
                
                const existingIndex = database.outlets.findIndex(o => o.id === outlet.id);
                if (existingIndex !== -1) {
                    database.outlets[existingIndex] = cleanOutlet;
                } else {
                    database.outlets.push(cleanOutlet);
                }
                saveToLocalStorage();
                return true;
            }
        }

        async function deleteOutlet(outletId) {
            if (currentUser.role !== 'admin') return;
            
            try {
                // Try Supabase first
                const { error } = await supabase
                    .from('outlets')
                    .delete()
                    .eq('id', outletId);
                
                if (error) {
                    console.error('Supabase delete outlet error:', error);
                }
                
                // Remove from local storage regardless
                database.outlets = database.outlets.filter(o => o.id !== outletId);
                saveToLocalStorage();
                loadOutlets();
                showNotification('Outlet deleted successfully', 'success');
                
            } catch (error) {
                console.error('Error deleting outlet:', error);
                // Fallback to local storage
                database.outlets = database.outlets.filter(o => o.id !== outletId);
                saveToLocalStorage();
                loadOutlets();
                showNotification('Outlet deleted successfully', 'success');
            }
        }

        async function saveUser(user) {
            if (currentUser.role !== 'admin') return;
            
            try {
                console.log('Saving user to Supabase:', user);
                
                // Ensure consistent field names
                const userToSave = {
                    id: user.id,
                    name: user.name,
                    username: user.username,
                    password: user.password,
                    outlet_id: user.outlet_id || user.outletId,
                    role: user.role || 'user'
                };
                
                // Remove duplicate field if exists
                if (userToSave.outletId) {
                    delete userToSave.outletId;
                }
                
                // Try Supabase first
                const { error } = await supabase
                    .from('users')
                    .upsert(userToSave);
                
                if (error) {
                    console.error('Supabase save user error:', error);
                    // Fallback to local storage
                    const existingIndex = database.users.findIndex(u => u.id === user.id);
                    if (existingIndex !== -1) {
                        database.users[existingIndex] = userToSave;
                    } else {
                        database.users.push(userToSave);
                    }
                    saveToLocalStorage();
                } else {
                    console.log('User saved to Supabase:', userToSave);
                    // Update local storage too
                    const existingIndex = database.users.findIndex(u => u.id === user.id);
                    if (existingIndex !== -1) {
                        database.users[existingIndex] = userToSave;
                    } else {
                        database.users.push(userToSave);
                    }
                    saveToLocalStorage();
                }
                
                // Force reload users from Supabase to ensure consistency
                await loadUsers();
                
                return true;
                
            } catch (error) {
                console.error('Error saving user:', error);
                // Fallback to local storage
                const userToSave = {
                    id: user.id,
                    name: user.name,
                    username: user.username,
                    password: user.password,
                    outlet_id: user.outlet_id || user.outletId,
                    role: user.role || 'user'
                };
                
                const existingIndex = database.users.findIndex(u => u.id === user.id);
                if (existingIndex !== -1) {
                    database.users[existingIndex] = userToSave;
                } else {
                    database.users.push(userToSave);
                }
                saveToLocalStorage();
                return true;
            }
        }

        async function deleteUser(userId) {
            if (currentUser.role !== 'admin') return;
            
            try {
                // Try Supabase first
                const { error } = await supabase
                    .from('users')
                    .delete()
                    .eq('id', userId);
                
                if (error) {
                    console.error('Supabase delete user error:', error);
                }
                
                // Remove from local storage regardless
                database.users = database.users.filter(u => u.id !== userId);
                saveToLocalStorage();
                loadUsers();
                showNotification('User deleted successfully', 'success');
                
            } catch (error) {
                console.error('Error deleting user:', error);
                // Fallback to local storage
                database.users = database.users.filter(u => u.id !== userId);
                saveToLocalStorage();
                loadUsers();
                showNotification('User deleted successfully', 'success');
            }
        }

        function displayOrders(orders) {
            ordersContainer.innerHTML = '';
            
            // Filter orders by current user's outlet if not admin
            let userOrders = currentUser.role === 'admin' 
                ? [...orders] 
                : orders.filter(order => {
                    // Handle both field name formats
                    const outletId = order.outlet_id || order.outletId;
                    return outletId === currentUser.outlet_id;
                });
            
            // Sort orders by date (newest first)
            userOrders.sort((a, b) => {
                const dateA = a.created_at || a.createdAt || a.date;
                const dateB = b.created_at || b.createdAt || b.date;
                return new Date(dateB) - new Date(dateA);
            });
            
            if (userOrders.length === 0) {
                ordersContainer.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-clipboard-list"></i>
                        <p>No orders found</p>
                    </div>
                `;
                return;
            }
            
            userOrders.forEach(order => {
                // Get outlet name - handle both field name formats
                const outletId = order.outlet_id || order.outletId;
                let outletName = 'Unknown';
                
                if (currentUser.role === 'admin') {
                    const outlet = database.outlets.find(o => o.id === outletId);
                    outletName = outlet ? outlet.name : 'Unknown';
                } else {
                    const outlet = database.outlets.find(o => o.id === currentUser.outlet_id);
                    outletName = outlet ? outlet.name : 'Unknown';
                }
                
                const orderCard = document.createElement('div');
                orderCard.className = 'order-card';
                
                // Format items list
                const itemsText = order.items.map(item => 
                    `${item.name} (${item.quantity} ${item.unit})`
                ).join(', ');
                
                // Use the actual order ID from the data, not a generated one
                const orderId = order.id;
                
                // Display "Received" to users but store as "completed" in database
                const displayStatus = order.status === 'completed' ? 'received' : order.status;
                
                orderCard.innerHTML = `
                    <div class="order-header">
                        <div>
                            <div class="order-id">${orderId}</div>
                            <div class="order-outlet">${outletName}</div>
                        </div>
                        <div>
                            <div class="order-date">${order.date}</div>
                            <span class="order-status status-${order.status}">${displayStatus}</span>
                        </div>
                    </div>
                    <div class="order-items">
                        ${itemsText || 'No items'}
                    </div>
                    <div class="action-buttons" style="margin-top: 10px;">
                        <button class="btn btn-warning btn-sm edit-order" data-id="${orderId}">
                            <i class="fas fa-edit"></i> Edit
                        </button>
                        <button class="btn btn-info btn-sm pdf-order" data-id="${orderId}">
                            <i class="fas fa-file-pdf"></i> PDF
                        </button>
                        ${currentUser.role === 'admin' && order.status === 'pending' ? `
                        <button class="btn btn-success btn-sm mark-received" data-id="${orderId}">
                            <i class="fas fa-check"></i> Mark Received
                        </button>
                        ` : ''}
                        ${currentUser.role === 'admin' ? `
                        <button class="btn btn-danger btn-sm delete-order" data-id="${orderId}">
                            <i class="fas fa-trash"></i> Delete
                        </button>
                        ` : `
                        <!-- Allow users to delete their own orders -->
                        ${outletId === currentUser.outlet_id ? `
                        <button class="btn btn-danger btn-sm delete-order" data-id="${orderId}">
                            <i class="fas fa-trash"></i> Delete
                        </button>
                        ` : ''}
                        `}
                    </div>
                `;
                
                ordersContainer.appendChild(orderCard);
            });
        }

        async function markOrderReceived(orderId) {
            try {
                showSyncStatus('Updating order status...', 'pending');
                
                const order = database.orders.find(o => o.id === orderId);
                if (!order) {
                    showNotification('Order not found', 'error');
                    return;
                }
                
                // Update order status to "completed" (to match Supabase constraint)
                order.status = 'completed';
                order.updated_at = new Date().toISOString();
                
                // Save to Supabase
                let supabaseSuccess = false;
                try {
                    const { error } = await supabase
                        .from('orders')
                        .update({
                            status: 'completed',
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', orderId);
                    
                    if (error) {
                        throw error;
                    }
                    supabaseSuccess = true;
                    
                } catch (supabaseError) {
                    console.error('Supabase update failed:', supabaseError);
                }
                
                // Always update local storage
                saveToLocalStorage();
                
                // Reload orders to reflect the change
                loadOrders();
                
                if (supabaseSuccess) {
                    showNotification(`Order ${orderId} marked as received`, 'success');
                } else {
                    showNotification(`Order ${orderId} marked as received (offline)`, 'warning');
                }
                
            } catch (error) {
                console.error('Error marking order as received:', error);
                showNotification('Error updating order status', 'error');
            }
        }

        async function loadItems() {
            if (currentUser.role !== 'admin') return;
            
            console.log('=== loadItems() called ==='); // Debug
            console.log('Current database.items:', database.items); // Debug
            console.log('Current database.items length:', database.items.length); // Debug
            
            try {
                let items = [];
                
                // Try Supabase first
                const { data, error } = await supabase
                    .from('items')
                    .select('*')
                    .order('name');
                
                if (error) {
                    console.error('Supabase items error:', error);
                    // Fallback to local storage
                    items = [...database.items];
                } else {
                    items = data || [];
                    console.log('Supabase items:', items); // Debug
                    
                    // If we got data from Supabase, update local database
                    if (items.length > 0) {
                        database.items = items;
                        saveToLocalStorage();
                    }
                }
                
                console.log('Final items to display:', items); // Debug
                displayItems(items);
                
            } catch (error) {
                console.error('Error loading items:', error);
                // Fallback to local storage
                console.log('Using local items due to error:', database.items); // Debug
                displayItems([...database.items]);
            }
        }

        function displayItems(items) {
            console.log('=== displayItems() called ==='); // Debug
            console.log('Items received:', items); // Debug
            console.log('Items length:', items.length); // Debug
            
            itemsList.innerHTML = '';
            
            if (items.length === 0) {
                console.log('No items to display'); // Debug
                itemsList.innerHTML = `
                    <tr>
                        <td colspan="4" class="empty-state">
                            <i class="fas fa-box-open"></i>
                            <p>No items found</p>
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Precompute which items are in orders
            const itemsInUse = new Set();
            database.orders.forEach(order => {
                if (order.items) {
                    order.items.forEach(item => {
                        itemsInUse.add(item.id);
                    });
                }
            });
            
            console.log('Items in use:', itemsInUse); // Debug
            
            items.forEach(item => {
                console.log('Processing item:', item); // Debug
                const isItemInUse = itemsInUse.has(item.id);
                const itemRow = document.createElement('tr');
                
                if (isItemInUse) {
                    itemRow.style.opacity = '0.7';
                }
                
                itemRow.innerHTML = `
                    <td>${item.name} ${isItemInUse ? '<span style="color: var(--warning); font-size: 0.8rem;">(in use)</span>' : ''}</td>
                    <td>${item.category}</td>
                    <td><span class="unit-badge">${item.unit}</span></td>
                    <td class="action-buttons">
                        <button class="btn btn-warning btn-sm edit-item" data-id="${item.id}">
                            <i class="fas fa-edit"></i> Edit
                        </button>
                        <button class="btn btn-danger btn-sm delete-item" data-id="${item.id}" 
                            ${isItemInUse ? 'disabled title="Cannot delete - item is used in orders"' : ''}>
                            <i class="fas fa-trash"></i> Delete
                        </button>
                    </td>
                `;
                
                itemsList.appendChild(itemRow);
            });
            
            console.log('Finished displaying items'); // Debug
        }

        function isItemInOrders(itemId) {
            return database.orders.some(order => 
                order.items && order.items.some(item => item.id === itemId)
            );
        }

        function displayOutlets(outlets) {
            outletsList.innerHTML = '';
            
            // Update the global database.outlets
            database.outlets = outlets;
            saveToLocalStorage(); // Save to localStorage for other devices
            
            if (outlets.length === 0) {
                outletsList.innerHTML = `
                    <tr>
                        <td colspan="3" class="empty-state">
                            <i class="fas fa-store"></i>
                            <p>No outlets found</p>
                        </td>
                    </tr>
                `;
                return;
            }
            
            outlets.forEach(outlet => {
                const outletRow = document.createElement('tr');
                
                // Clean the outlet name - remove any surrounding quotes
                let cleanName = outlet.name;
                if (typeof cleanName === 'string') {
                    cleanName = cleanName.replace(/^['"](.*)['"]$/, '$1').trim();
                }
                
                let cleanLocation = outlet.location;
                if (typeof cleanLocation === 'string') {
                    cleanLocation = cleanLocation.replace(/^['"](.*)['"]$/, '$1').trim();
                }
                
                outletRow.innerHTML = `
                    <td>${cleanName}</td>
                    <td>${cleanLocation}</td>
                    <td class="action-buttons">
                        <button class="btn btn-warning btn-sm edit-outlet" data-id="${outlet.id}">
                            <i class="fas fa-edit"></i> Edit
                        </button>
                        <button class="btn btn-danger btn-sm delete-outlet" data-id="${outlet.id}">
                            <i class="fas fa-trash"></i> Delete
                        </button>
                    </td>
                `;
                
                outletsList.appendChild(outletRow);
            });
        }

        function displayUsers(users) {
            userList.innerHTML = '';
            
            if (users.length === 0) {
                userList.innerHTML = `
                    <tr>
                        <td colspan="5" class="empty-state">
                            <i class="fas fa-users"></i>
                            <p>No users found</p>
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Ensure outlets are loaded
            if (database.outlets.length === 0) {
                loadOutlets();
            }
            
            users.forEach(user => {
                const userRow = document.createElement('tr');
                
                // Handle both field name formats for outlet ID
                const outletId = user.outlet_id || user.outletId;
                let outletName = 'No Outlet';
                
                if (outletId) {
                    const outlet = database.outlets.find(o => o.id === outletId);
                    if (outlet) {
                        // Clean the outlet name for display
                        let cleanName = outlet.name;
                        if (typeof cleanName === 'string') {
                            cleanName = cleanName.replace(/^['"](.*)['"]$/, '$1').trim();
                        }
                        outletName = cleanName;
                    } else {
                        outletName = `<span style="color: var(--danger); font-weight: bold;">Outlet ID ${outletId} Not Found</span>`;
                    }
                } else {
                    outletName = `<span style="color: var(--warning); font-weight: bold;">No Outlet Assigned</span>`;
                }
                
                userRow.innerHTML = `
                    <td>${user.name}</td>
                    <td>${user.username}</td>
                    <td>${outletName}</td>
                    <td><span class="role-badge">${user.role}</span></td>
                    <td class="action-buttons">
                        <button class="btn btn-warning btn-sm edit-user" data-id="${user.id}">
                            <i class="fas fa-edit"></i> Edit
                        </button>
                        <button class="btn btn-danger btn-sm delete-user" data-id="${user.id}" 
                            ${user.role === 'admin' ? 'disabled title="Cannot delete admin users"' : ''}>
                            <i class="fas fa-trash"></i> Delete
                        </button>
                    </td>
                `;
                
                userList.appendChild(userRow);
            });
        }

        // Add this function to ensure outlets are loaded
        async function ensureOutletsLoaded() {
            console.log('Ensuring outlets are loaded...');
            console.log('Current database.outlets:', database.outlets);
            console.log('Current database.outlets length:', database.outlets.length);
            
            // If no outlets in local storage, load from Supabase
            if (database.outlets.length === 0) {
                console.log('No outlets in local storage, loading from Supabase...');
                try {
                    const { data, error } = await supabase
                        .from('outlets')
                        .select('*')
                        .order('name');
                    
                    if (error) {
                        console.error('Error loading outlets from Supabase:', error);
                        showNotification('Error loading outlets', 'error');
                        return false;
                    }
                    
                    if (data && data.length > 0) {
                        database.outlets = data;
                        saveToLocalStorage();
                        console.log('Loaded outlets from Supabase:', data.length);
                        return true;
                    } else {
                        console.log('No outlets found in Supabase');
                        showNotification('No outlets found. Please create outlets first.', 'error');
                        return false;
                    }
                } catch (error) {
                    console.error('Error loading outlets:', error);
                    showNotification('Error loading outlets', 'error');
                    return false;
                }
            }
            
            return true;
        }

        // Update the addUserBtn event listener to use this:
        addUserBtn.addEventListener('click', async () => {
            if (currentUser.role !== 'admin') return;
            
            // Ensure outlets are loaded from Supabase if needed
            const outletsLoaded = await ensureOutletsLoaded();
            if (!outletsLoaded) {
                return;
            }
            
            console.log('Outlets available:', database.outlets);
            
            editingId = null;
            userFormTitle.textContent = 'Add New User';
            userForm.style.display = 'block';
            newUserName.value = '';
            newUserUsername.value = '';
            newUserPassword.value = '';
            
            // Make sure outlets are loaded before setting default value
            if (database.outlets.length > 0) {
                // Use the populateOutletDropdown function (remove the duplicate manual code)
                populateOutletDropdown(newUserOutlet);
            } else {
                showNotification('No outlets available. Please create an outlet first.', 'error');
                userForm.style.display = 'none';
                return;
            }
        });
            

        // Helper functions
        function showSyncStatus(message, type) {
            syncStatus.style.display = 'flex';
            syncStatusText.textContent = message;
            syncStatus.className = `sync-status sync-${type}`;
            
            if (type === 'success') {
                setTimeout(() => {
                    syncStatus.style.display = 'none';
                }, 5000);
            }
        }

        function showNotification(message, type = 'success') {
            notification.textContent = message;
            notification.className = `notification notification-${type}`;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        function getOutletName(outletId) {
            const outlet = database.outlets.find(o => o.id === outletId);
            if (!outlet) return 'Unknown';
            
            // Clean the outlet name for display
            let cleanName = outlet.name;
            if (typeof cleanName === 'string') {
                cleanName = cleanName.replace(/^['"](.*)['"]$/, '$1').trim();
            }
            
            return cleanName;
        }

        // Generate order ID based on outlet name
        function generateOrderId(outletId) {
            // If no outlet ID provided, use a default
            if (!outletId) {
                console.warn('No outletId provided, using default');
                outletId = database.outlets.length > 0 ? database.outlets[0].id : 1;
            }
            
            const outlet = database.outlets.find(o => o.id === outletId);
            if (!outlet) {
                console.error('Outlet not found for ID:', outletId);
                // Use a fallback prefix
                return `UNKNOWN${Date.now()}`;
            }
            
            // Get first 10 characters of outlet name, pad with zeros if needed
            let outletPrefix = outlet.name.substring(0, 10).toUpperCase().replace(/\s+/g, '');
            if (outletPrefix.length < 10) {
                outletPrefix = outletPrefix.padEnd(10, '0');
            }
            
            // Initialize counter for this outlet if not exists
            if (!database.orderCounter[outletId]) {
                // Find the highest existing order number for this outlet
                const existingOrders = database.orders.filter(order => {
                    const orderPrefix = order.id.substring(0, 10);
                    return orderPrefix === outletPrefix;
                });
                
                if (existingOrders.length > 0) {
                    const highestNumber = Math.max(...existingOrders.map(order => {
                        const numberPart = order.id.substring(10);
                        return parseInt(numberPart) || 0;
                    }));
                    database.orderCounter[outletId] = highestNumber + 1;
                } else {
                    database.orderCounter[outletId] = 1;
                }
            }
            
            // Generate sequential number with leading zeros
            const orderNumber = database.orderCounter[outletId].toString().padStart(6, '0');
            
            // Check if this ID already exists
            const newOrderId = `${outletPrefix}${orderNumber}`;
            const idExists = database.orders.some(order => order.id === newOrderId);
            
            if (idExists) {
                // If ID exists, increment and try again
                database.orderCounter[outletId]++;
                return generateOrderId(outletId); // Recursive call with incremented counter
            }
            
            database.orderCounter[outletId]++;
            return newOrderId;
        }

        async function showApp() {
            loginScreen.style.display = 'none';
            appScreen.style.display = 'block';
            
            // Update UI based on user
            userName.textContent = `User: ${currentUser.name}`;
            userRole.textContent = currentUser.role === 'admin' ? 'Admin' : 'User';
            
            // For regular users, show their outlet
            if (currentUser.role !== 'admin' && currentUser.outlet_id) {
                const outlet = database.outlets.find(o => o.id === currentUser.outlet_id);
                if (outlet) {
                    // Clean the outlet name for display
                    let cleanName = outlet.name;
                    if (typeof cleanName === 'string') {
                        cleanName = cleanName.replace(/^['"](.*)['"]$/, '$1').trim();
                    }
                    currentOutlet.textContent = cleanName;
                } else {
                    currentOutlet.textContent = 'Outlet Not Found';
                    console.error('User outlet not found:', currentUser.outlet_id);
                }
            } else if (currentUser.role === 'admin') {
                currentOutlet.textContent = 'All Outlets (Admin)';
            }
            
            // Show/hide tabs based on user role
            if (currentUser.role === 'admin') {
                adminTab1.style.display = 'flex';
                adminTab2.style.display = 'flex';
                adminTab3.style.display = 'flex';
                // Show admin-only buttons
                document.querySelectorAll('.admin-only').forEach(btn => {
                    btn.style.display = 'inline-flex';
                });
            } else {
                adminTab1.style.display = 'none';
                adminTab2.style.display = 'none';
                adminTab3.style.display = 'none';
                // Hide admin-only buttons
                document.querySelectorAll('.admin-only').forEach(btn => {
                    btn.style.display = 'none';
                });
            }
            
            // Fix any users with null outlets
            await fixUsersWithNullOutlets();
            
            // Load initial data
            loadOrders();
            if (currentUser.role === 'admin') {
                // Force reload from Supabase
                await loadUsers(); // This will now load from Supabase
                await loadItems();
                await loadOutlets();
            }
            updateCart();
        }

        // Logout function
        function logout() {
            currentUser = null;
            cart = [];
            appScreen.style.display = 'none';
            loginScreen.style.display = 'block';
            usernameInput.value = '';
            passwordInput.value = '';
        }

        // Update cart display
        function updateCart() {
            cartItems.innerHTML = '';
            
            if (cart.length === 0) {
                cartItems.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-shopping-cart"></i>
                        <h3>Your cart is empty</h3>
                        <p>Search and add items to get started</p>
                    </div>
                `;
            } else {
                cart.forEach(item => {
                    const cartItem = document.createElement('div');
                    cartItem.className = 'cart-item';
                    
                    cartItem.innerHTML = `
                        <div class="cart-item-details">
                            <div class="cart-item-name">${item.name} <span class="unit-badge">${item.unit}</span></div>
                            <div class="cart-item-quantity">
                                <input type="number" class="quantity-input" value="${item.quantity}" min="0.1" step="${item.unit === 'KGS' ? '0.1' : '1'}" data-id="${item.id}">
                                <button class="remove-item" data-id="${item.id}">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                        </div>
                    `;
                    
                    cartItems.appendChild(cartItem);
                });
            }
            
            // Update cart count
            cartCount.textContent = `(${cart.length})`;
            totalItems.textContent = cart.length;
        }

        // Add item to cart
        function addToCart(itemId, quantity = null) {
            const item = database.items.find(i => i.id === itemId);
            
            if (!item) return;
            
            // If quantity not provided, use default based on unit
            if (quantity === null) {
                quantity = item.unit === 'KGS' ? 1.0 : 1;
            }
            
            const existingItem = cart.find(cartItem => cartItem.id === itemId);
            
            if (existingItem) {
                existingItem.quantity += quantity;
            } else {
                cart.push({
                    id: item.id,
                    name: item.name,
                    quantity: quantity,
                    unit: item.unit
                });
            }
            
            updateCart();
            showNotification(`${quantity} ${item.unit} of ${item.name} added to cart`, 'success');
        }

        // Add this function to populate the outlet dropdown
        function populateOutletDropdown(selectElement, selectedOutletId = null) {
            console.log('Populating outlet dropdown...');
            console.log('Available outlets:', database.outlets);
            
            selectElement.innerHTML = '';
            
            if (!database.outlets || database.outlets.length === 0) {
                console.log('No outlets available for dropdown');
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No outlets available';
                selectElement.appendChild(option);
                selectElement.disabled = true;
                return;
            }
            
            database.outlets.forEach(outlet => {
                const option = document.createElement('option');
                option.value = outlet.id;
                
                // Clean the name for display
                let cleanName = outlet.name;
                if (typeof cleanName === 'string') {
                    cleanName = cleanName.replace(/^['"](.*)['"]$/, '$1').trim();
                }
                
                option.textContent = cleanName;
                selectElement.appendChild(option);
            });
            
            selectElement.disabled = false;
            
            // Set selected value if provided
            if (selectedOutletId) {
                selectElement.value = selectedOutletId;
            } else if (database.outlets.length > 0) {
                selectElement.value = database.outlets[0].id;
            }
            
            console.log('Outlet dropdown populated with', database.outlets.length, 'outlets');
        }

        function generatePDF(order) {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            // Page dimensions
            const pageWidth = doc.internal.pageSize.getWidth();
            const margin = 10; // Smaller margins
            const contentWidth = pageWidth - (margin * 2);
            
            // Add header with smaller font
            doc.setFontSize(16);
            doc.setTextColor(40);
            doc.text('ORDER CONFIRMATION', pageWidth / 2, 15, { align: 'center' });
            
            // Add order information with smaller font
            doc.setFontSize(8);
            doc.text(`Order ID: ${order.id}`, margin, 25);
            doc.text(`Outlet: ${getOutletName(order.outlet_id)}`, margin, 32);
            doc.text(`Date: ${order.date}`, margin, 39);
            
            // Display "Received" instead of "Completed"
            const displayStatus = order.status === 'completed' ? 'received' : order.status;
            doc.text(`Status: ${displayStatus.toUpperCase()}`, margin, 46);
            
            // Add items table with compact layout
            const columnStyles = {
                0: { cellWidth: contentWidth * 0.55, fontSize: 7, fontStyle: 'normal' }, // Item name
                1: { cellWidth: contentWidth * 0.25, fontSize: 7, fontStyle: 'bold' },   // Quantity
                2: { cellWidth: contentWidth * 0.20, fontSize: 7, fontStyle: 'normal' }  // Unit
            };
            
            // Prepare table data - ensure no content is too long
            const tableData = order.items.map(item => [
                truncateText(item.name, 35), // Truncate long item names
                item.quantity.toString(),
                item.unit
            ]);
            
            doc.autoTable({
                startY: 50,
                head: [['Item', 'Quantity', 'Unit']],
                body: tableData,
                theme: 'grid',
                headStyles: { 
                    fillColor: [52, 152, 219],
                    fontSize: 8,
                    textColor: 255,
                    cellPadding: 2
                },
                styles: { 
                    fontSize: 7,
                    cellPadding: 2,
                    lineColor: [150, 150, 150],
                    lineWidth: 0.1,
                    minCellHeight: 6
                },
                columnStyles: columnStyles,
                margin: { left: margin, right: margin },
                tableWidth: contentWidth
            });
            
            // Add footer
            const finalY = doc.lastAutoTable.finalY + 10;
            doc.setFontSize(8);
            doc.text('Thank you for your order!', pageWidth / 2, finalY, { align: 'center' });
            doc.text('Generated by Outlet Order System', pageWidth / 2, finalY + 6, { align: 'center' });
            
            return doc;
        }

        // Helper function to truncate long text
        function truncateText(text, maxLength) {
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength - 3) + '...';
        }

        function showPDFPreview(order) {
            currentPdfOrder = order;
            const outlet = database.outlets.find(o => o.id === order.outlet_id);
            
            // Display "Received" instead of "Completed" in the UI
            const displayStatus = order.status === 'completed' ? 'received' : order.status;
            
            // Generate HTML preview
            const previewHTML = `
                <div class="pdf-preview">
                    <div class="pdf-header">
                        <h2>ORDER CONFIRMATION</h2>
                    </div>
                    <div class="pdf-order-info">
                        <div>
                            <p><strong>Order ID:</strong> ${order.id}</p>
                            <p><strong>Outlet:</strong> ${outlet ? outlet.name : 'Unknown'}</p>
                        </div>
                        <div>
                            <p><strong>Date:</strong> ${order.date}</p>
                            <p><strong>Status:</strong> <span class="order-status status-${order.status}">${displayStatus}</span></p>
                        </div>
                    </div>
                    <table class="pdf-items-table">
                        <thead>
                            <tr>
                                <th>Item</th>
                                <th>Quantity</th>
                                <th>Unit</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${order.items.map(item => `
                                <tr>
                                    <td>${item.name}</td>
                                    <td>${item.quantity}</td>
                                    <td>${item.unit}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                    <div class="pdf-footer">
                        <p>Thank you for your order!</p>
                        <p><small>Generated by Outlet Order System</small></p>
                    </div>
                </div>
            `;
            
            pdfPreviewContent.innerHTML = previewHTML;
            pdfModal.style.display = 'flex';
        }

        function downloadPDF(order) {
            const doc = generatePDF(order);
            doc.save(`order-${order.id}.pdf`);
        }

        function printPDF(order) {
            const doc = generatePDF(order);
            doc.autoPrint();
            doc.output('dataurlnewwindow');
        }

        function sharePDF(order) {
            if (navigator.share) {
                const doc = generatePDF(order);
                const pdfBlob = doc.output('blob');
                const file = new File([pdfBlob], `order-${order.id}.pdf`, { type: 'application/pdf' });
                
                navigator.share({
                    title: `Order ${order.id}`,
                    text: `Order confirmation for ${getOutletName(order.outlet_id)}`,
                    files: [file]
                }).catch(error => {
                    console.error('Error sharing:', error);
                    showNotification('Sharing failed. Please download instead.', 'error');
                });
            } else {
                showNotification('Sharing not supported on this device. Please download the PDF.', 'warning');
                downloadPDF(order);
            }
        }

        // Import/Export Functions
        function exportItemsToExcel() {
            try {
                // Create worksheet from items data
                const ws = XLSX.utils.json_to_sheet(database.items.map(item => ({
                    "Item Name": item.name,
                    "Category": item.category,
                    "Unit": item.unit
                })));
                
                // Create workbook and add worksheet
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "Items");
                
                // Generate Excel file and trigger download
                XLSX.writeFile(wb, "outlet_items.xlsx");
                showNotification("Items exported successfully", "success");
            } catch (error) {
                console.error("Error exporting items:", error);
                showNotification("Error exporting items", "error");
            }
        }

        function importItemsFromExcel(file) {
            try {
                const reader = new FileReader();
                
                reader.onload = async function(e) { // Make this async
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        
                        // Get first worksheet
                        const worksheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[worksheetName];
                        const jsonData = XLSX.utils.sheet_to_json(worksheet);
                        
                        console.log('Imported raw data:', jsonData);
                        
                        if (jsonData.length === 0) {
                            showNotification("No data found in file", "error");
                            return;
                        }
                        
                        // Validate and process imported data
                        const newItems = [];
                        let validItems = 0;
                        let skippedItems = 0;
                        
                        // Get the next available ID
                        let nextId = Math.max(0, ...database.items.map(i => i.id)) + 1;
                        
                        jsonData.forEach((row, index) => {
                            // Check for required fields with flexible column names
                            const itemName = row["Item Name"] || row["item_name"] || row["Item"] || row["item"] || row["Name"] || row["name"];
                            const category = row["Category"] || row["category"] || row["Type"] || row["type"] || "General";
                            const unit = row["Unit"] || row["unit"] || "PCS";
                            
                            if (itemName && typeof itemName === 'string' && itemName.trim() !== '') {
                                const trimmedName = itemName.toString().trim();
                                const trimmedCategory = category.toString().trim();
                                let trimmedUnit = unit.toString().toUpperCase().trim();
                                
                                // Validate and normalize unit
                                if (trimmedUnit !== "KGS" && trimmedUnit !== "PCS") {
                                    trimmedUnit = "PCS";
                                }
                                
                                // Check if item already exists (case insensitive)
                                const existingItem = database.items.find(
                                    item => item.name.toLowerCase() === trimmedName.toLowerCase()
                                );
                                
                                if (!existingItem) {
                                    const newItem = {
                                        id: nextId++,
                                        name: trimmedName,
                                        category: trimmedCategory,
                                        unit: trimmedUnit
                                    };
                                    
                                    newItems.push(newItem);
                                    validItems++;
                                } else {
                                    console.log(`Skipped duplicate item: ${trimmedName}`);
                                    skippedItems++;
                                }
                            } else {
                                console.log(`Skipped invalid row ${index + 1}:`, row);
                                skippedItems++;
                            }
                        });
                        
                        if (validItems === 0) {
                            if (skippedItems > 0) {
                                showNotification(`No valid new items found. ${skippedItems} items skipped (duplicates or invalid data).`, "error");
                            } else {
                                showNotification("No valid items found in file", "error");
                            }
                            return;
                        }
                        
                        console.log('New items to add:', newItems);
                        
                        // Add new items to database
                        database.items.push(...newItems);
                        console.log('Database items after import:', database.items);
                        
                        // Save to localStorage
                        saveToLocalStorage();
                        console.log('Saved to localStorage');
                        
                        // Save to Supabase if possible - wait for all to complete
                        if (currentUser.role === 'admin') {
                            const savePromises = newItems.map(item => saveItem(item));
                            await Promise.all(savePromises);
                        }
                        
                        // Force refresh the items display
                        console.log('Calling loadItems() to refresh display');
                        await loadItems(); // Wait for loadItems to complete
                        
                        let message = `Successfully imported ${validItems} items`;
                        if (skippedItems > 0) {
                            message += `, ${skippedItems} items skipped (duplicates or invalid data)`;
                        }
                        showNotification(message, "success");
                        
                    } catch (error) {
                        console.error("Error processing file:", error);
                        showNotification("Error processing file: " + error.message, "error");
                    }
                };
                
                reader.onerror = function() {
                    showNotification("Error reading file", "error");
                };
                
                reader.readAsArrayBuffer(file);
            } catch (error) {
                console.error("Error importing items:", error);
                showNotification("Error importing items: " + error.message, "error");
            }
        }

        // Duplicate checking functions
        function checkLocalDuplicates() {
            const orderIdCounts = {};
            const duplicates = [];

            database.orders.forEach(order => {
                if (!orderIdCounts[order.id]) {
                    orderIdCounts[order.id] = [];
                }
                orderIdCounts[order.id].push(order);
            });

            // Find duplicates
            for (const [orderId, orders] of Object.entries(orderIdCounts)) {
                if (orders.length > 1) {
                    duplicates.push({
                        orderId: orderId,
                        orders: orders,
                        count: orders.length
                    });
                }
            }

            return duplicates;
        }

        function removeLocalDuplicates() {
            const uniqueOrders = [];
            const seenOrderIds = new Set();
            let removedCount = 0;

            // Keep the most recent order for each Order ID
            database.orders
                .sort((a, b) => new Date(b.created_at) - new Date(a.created_at)) // Sort by date (newest first)
                .forEach(order => {
                    if (!seenOrderIds.has(order.id)) {
                        uniqueOrders.push(order);
                        seenOrderIds.add(order.id);
                    } else {
                        removedCount++;
                    }
                });

            database.orders = uniqueOrders;
            saveToLocalStorage();
            loadOrders();

            return removedCount;
        }

        // Setup event listeners
        function setupEventListeners() {
            // Login
            loginBtn.addEventListener('click', () => {
                const username = usernameInput.value;
                const password = passwordInput.value;
                
                if (username && password) {
                    login(username, password);
                } else {
                    showNotification('Please enter both username and password', 'error');
                }
            });
            
            // Allow login with Enter key
            passwordInput.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') {
                    loginBtn.click();
                }
            });
            
            // Logout
            logoutBtn.addEventListener('click', logout);
            
            // Tab switching
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabId = tab.getAttribute('data-tab');
                    
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(tc => tc.classList.remove('active'));
                    
                    tab.classList.add('active');
                    document.getElementById(`${tabId}-tab`).classList.add('active');
                });
            });
            
            // Refresh orders
            syncOrdersBtn.addEventListener('click', loadOrders);
            
            // Import/Export items
            exportItemsBtn.addEventListener('click', exportItemsToExcel);
            importItemsBtn.addEventListener('click', () => {
                importFileInput.click();
            });
            importFileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    importItemsFromExcel(e.target.files[0]);
                    e.target.value = ''; // Reset file input
                }
            });
            
            // Refresh orders with better sync feedback
            syncOrdersBtn.addEventListener('click', async () => {
                await loadOrders();
            });

            // Add auto-sync every 30 seconds when online
            setInterval(() => {
                if (navigator.onLine && currentUser) {
                    loadOrders();
                    syncDeletedOrders(); 
                    syncLocalDeletionsToSupabase();
                }
            }, 30000);

            // PDF Modal handlers
            closePdfModal.addEventListener('click', () => {
                pdfModal.style.display = 'none';
            });
            
            printPdfBtn.addEventListener('click', () => {
                if (currentPdfOrder) {
                    printPDF(currentPdfOrder);
                }
            });
            
            downloadPdfBtn.addEventListener('click', () => {
                if (currentPdfOrder) {
                    downloadPDF(currentPdfOrder);
                }
            });
            
            sharePdfBtn.addEventListener('click', () => {
                if (currentPdfOrder) {
                    sharePDF(currentPdfOrder);
                }
            });
            
            // Close modal when clicking outside
            pdfModal.addEventListener('click', (e) => {
                if (e.target === pdfModal) {
                    pdfModal.style.display = 'none';
                }
            });

            // Duplicate checking
            document.getElementById('checkDuplicatesBtn').addEventListener('click', () => {
                const localDuplicates = checkLocalDuplicates();
                
                if (localDuplicates.length > 0) {
                    let message = `Found ${localDuplicates.length} duplicate orders locally:\n`;
                    localDuplicates.forEach(dup => {
                        message += ` Order ${dup.orderId}: ${dup.count} copies\n`;
                    });
                    
                    if (confirm(`${message}\n\nRemove local duplicates?`)) {
                        const removed = removeLocalDuplicates();
                        showNotification(`Removed ${removed} local duplicates`, 'success');
                    }
                } else {
                    showNotification('No duplicate orders found', 'success');
                }
            });

            document.getElementById('removeDuplicatesBtn').addEventListener('click', () => {
                if (confirm('This will remove duplicate orders from local storage. Continue?')) {
                    const localRemoved = removeLocalDuplicates();
                    
                    if (localRemoved > 0) {
                        showNotification(`Removed ${localRemoved} local duplicates`, 'success');
                    } else {
                        showNotification('No duplicate orders found', 'info');
                    }
                }
            });

            // Item search with autocomplete
            itemSearch.addEventListener('input', () => {
                const searchTerm = itemSearch.value.toLowerCase();
                
                if (searchTerm.length < 2) {
                    itemSuggestions.style.display = 'none';
                    return;
                }
                
                const filteredItems = database.items.filter(item => 
                    item.name.toLowerCase().includes(searchTerm) ||
                    item.category.toLowerCase().includes(searchTerm)
                );
                
                if (filteredItems.length === 0) {
                    itemSuggestions.style.display = 'none';
                    return;
                }
                
                itemSuggestions.innerHTML = '';
                filteredItems.forEach(item => {
                    const suggestion = document.createElement('div');
                    suggestion.className = 'suggestion-item';
                    
                    // Create quantity input for the suggestion
                    const quantityInput = document.createElement('input');
                    quantityInput.type = 'number';
                    quantityInput.min = item.unit === 'KGS' ? '0.1' : '1';
                    quantityInput.step = item.unit === 'KGS' ? '0.1' : '1';
                    quantityInput.value = item.unit === 'KGS' ? '1.0' : '1';
                    quantityInput.style.width = '60px';
                    quantityInput.style.padding = '5px';
                    quantityInput.style.border = '1px solid #ddd';
                    quantityInput.style.borderRadius = '3px';
                    
                    suggestion.innerHTML = `
                        <span>${item.name} (${item.category}) - ${item.unit}</span>
                    `;
                    suggestion.appendChild(quantityInput);
                    
                    const addButton = document.createElement('button');
                    addButton.className = 'btn btn-success btn-sm';
                    addButton.innerHTML = '<i class="fas fa-plus"></i> Add';
                    addButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const quantity = parseFloat(quantityInput.value);
                        if (quantity > 0) {
                            addToCart(item.id, quantity);
                            itemSearch.value = '';
                            itemSuggestions.style.display = 'none';
                        }
                    });
                    
                    suggestion.appendChild(addButton);
                    itemSuggestions.appendChild(suggestion);
                });
                
                itemSuggestions.style.display = 'block';
            });
            
            // Hide suggestions when clicking outside
            document.addEventListener('click', (e) => {
                if (!itemSearch.contains(e.target) && !itemSuggestions.contains(e.target)) {
                    itemSuggestions.style.display = 'none';
                }
            });
            
            // Clear cart
            clearCartBtn.addEventListener('click', () => {
                cart = [];
                currentOrderId = null;
                updateCart();
                showNotification('Cart cleared', 'success');
            });
            
            // Confirm order
            confirmOrderBtn.addEventListener('click', async () => {
                if (cart.length === 0) {
                    showNotification('Cart is empty', 'error');
                    return;
                }
                
                // Determine outlet ID - FIXED VERSION
                let outletId;
                if (currentUser.role === 'admin') {
                    // For admin, use the first outlet as default
                    outletId = database.outlets.length > 0 ? database.outlets[0].id : 1;
                    console.log('Admin creating order for outlet:', outletId);
                } else {
                    // For regular users, use their assigned outlet
                    outletId = currentUser.outlet_id || currentUser.outletId;
                    console.log('User creating order for outlet:', outletId);
                }
                
                // Validate outletId
                if (!outletId) {
                    console.error('No outlet found for user:', currentUser);
                    console.error('User outlet_id:', currentUser.outlet_id);
                    console.error('User outletId:', currentUser.outletId);
                    console.error('Available outlets:', database.outlets);
                    showNotification('Error: No outlet assigned. Please contact administrator.', 'error');
                    return;
                }
                
                // Verify outlet exists
                const outletExists = database.outlets.some(outlet => outlet.id === outletId);
                if (!outletExists) {
                    console.error('Outlet does not exist:', outletId);
                    showNotification('Error: Invalid outlet assigned. Please contact administrator.', 'error');
                    return;
                }
                
                if (currentOrderId) {
                    // Update existing order
                    const orderIndex = database.orders.findIndex(o => o.id === currentOrderId);
                    if (orderIndex !== -1) {
                        // Update with correct field names
                        database.orders[orderIndex].items = [...cart];
                        database.orders[orderIndex].date = new Date().toLocaleDateString();
                        database.orders[orderIndex].outletId = outletId;
                        database.orders[orderIndex].outlet_id = outletId;
                        database.orders[orderIndex].updated_at = new Date().toISOString();
                        
                        // Save to Supabase or local storage
                        await saveOrder(database.orders[orderIndex]);
                        
                        showNotification(`Order ${currentOrderId} updated successfully!`, 'success');
                    }
                } else {
                    // Create new order - FIXED
                    const orderId = generateOrderId(outletId);
                    const newOrder = {
                        id: orderId,
                        outletId: outletId,
                        outlet_id: outletId,
                        date: new Date().toLocaleDateString(),
                        createdAt: new Date().toISOString(),
                        created_at: new Date().toISOString(),
                        items: [...cart],
                        status: 'pending'
                    };
                    
                    console.log('Creating new order:', newOrder);
                    
                    // Save to Supabase or local storage
                    await saveOrder(newOrder);
                    
                    showNotification(`Order ${orderId} created successfully!`, 'success');
                }
                
                cart = [];
                currentOrderId = null;
                updateCart();
                loadOrders();
                
                // Switch to orders tab
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(tc => tc.classList.remove('active'));
                
                document.querySelector('.tab[data-tab="orders"]').classList.add('active');
                document.getElementById('orders-tab').classList.add('active');
            });
            
            // Create new order
            addOrderBtn.addEventListener('click', () => {
                cart = [];
                currentOrderId = null;
                updateCart();
                
                // Switch to cart tab
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(tc => tc.classList.remove('active'));
                
                document.querySelector('.tab[data-tab="cart"]').classList.add('active');
                document.getElementById('cart-tab').classList.add('active');
                
                showNotification('Ready to create new order. Search and add items to cart.', 'success');
            });
            
            // Edit and delete handlers for orders
            ordersContainer.addEventListener('click', (e) => {
                const target = e.target;
                
                // Find the closest button element
                let button = target.closest('.edit-order') || 
                            target.closest('.pdf-order') || 
                            target.closest('.delete-order') ||
                            target.closest('.mark-received'); // Add this line
                
                if (!button) return;
                
                const orderId = button.getAttribute('data-id');
                
                // Find order by ID - check both local database and Supabase data
                let order = database.orders.find(o => o.id === orderId);
                
                if (!order) {
                    console.log('Order not found:', orderId);
                    console.log('Available orders:', database.orders.map(o => o.id));
                    showNotification(`Order ${orderId} not found`, 'error');
                    return;
                }
                
                if (button.classList.contains('edit-order')) {
                    // Check if user has permission to edit this order
                    const outletId = order.outlet_id || order.outletId;
                    if (currentUser.role !== 'admin' && outletId !== currentUser.outlet_id) {
                        showNotification('You can only edit orders from your outlet', 'error');
                        return;
                    }
                    
                    // Properly load order items into cart
                    cart = Array.isArray(order.items) ? order.items : [];
                    currentOrderId = orderId;
                    updateCart();
                    
                    // Switch to cart tab
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(tc => tc.classList.remove('active'));
                    
                    document.querySelector('.tab[data-tab="cart"]').classList.add('active');
                    document.getElementById('cart-tab').classlist.add('active');
                    
                    showNotification(`Editing order ${orderId}. Make changes and confirm to update.`, 'success');
                }
                else if (button.classList.contains('pdf-order')) {
                    showPDFPreview(order);
                }
                else if (button.classList.contains('mark-received')) {
                    // Only admin can mark orders as received
                    if (currentUser.role !== 'admin') {
                        showNotification('Only administrators can mark orders as received', 'error');
                        return;
                    }
                    
                    if (confirm(`Mark order ${orderId} as received?`)) {
                        markOrderReceived(orderId);
                    }
                }
                else if (button.classList.contains('delete-order')) {
                    // Check permissions
                    const outletId = order.outlet_id || order.outletId;
                    if (currentUser.role !== 'admin' && outletId !== currentUser.outlet_id) {
                        showNotification('You can only delete orders from your outlet', 'error');
                        return;
                    }
                    
                    deleteOrder(orderId);
                }
            });

            // Item form handlers (admin only)
            addItemBtn.addEventListener('click', () => {
                if (currentUser.role !== 'admin') return;
                editingId = null;
                itemFormTitle.textContent = 'Add New Item';
                itemForm.style.display = 'block';
                itemName.value = '';
                itemCategory.value = '';
                itemUnit.value = 'KGS';
            });
            
            saveItemBtn.addEventListener('click', async () => {
                if (currentUser.role !== 'admin') return;
                const name = itemName.value.trim();
                const category = itemCategory.value.trim();
                const unit = itemUnit.value;
                
                if (!name || !category) {
                    showNotification('Please fill all required fields', 'error');
                    return;
                }
                
                if (editingId) {
                    // Update existing item
                    const itemIndex = database.items.findIndex(i => i.id === editingId);
                    if (itemIndex !== -1) {
                        database.items[itemIndex].name = name;
                        database.items[itemIndex].category = category;
                        database.items[itemIndex].unit = unit;
                        
                        // Save to Supabase or local storage
                        await saveItem(database.items[itemIndex]);
                        
                        showNotification('Item updated successfully', 'success');
                    }
                } else {
                    // Add new item
                    const newItem = {
                        id: database.items.length + 1,
                        name: name,
                        category: category,
                        unit: unit
                    };
                    database.items.push(newItem);
                    
                    // Save to Supabase or local storage
                    await saveItem(newItem);
                    
                    showNotification('Item created successfully', 'success');
                }
                
                itemForm.style.display = 'none';
                saveToLocalStorage();
                loadItems();
            });
            
            cancelItemBtn.addEventListener('click', () => {
                itemForm.style.display = 'none';
            });
            
            // Outlet form handlers (admin only)
            addOutletBtn.addEventListener('click', () => {
                if (currentUser.role !== 'admin') return;
                editingId = null;
                outletFormTitle.textContent = 'Add New Outlet';
                outletForm.style.display = 'block';
                outletName.value = '';
                outletLocation.value = '';
            });
            
            saveOutletBtn.addEventListener('click', async () => {
                if (currentUser.role !== 'admin') return;
                
                // Clean the input values - remove any surrounding whitespace and quotes
                const name = outletName.value.trim().replace(/^['"](.*)['"]$/, '$1').trim();
                const location = outletLocation.value.trim().replace(/^['"](.*)['"]$/, '$1').trim();
                
                if (!name || !location) {
                    showNotification('Please fill all required fields', 'error');
                    return;
                }
                
                if (editingId) {
                    // Update existing outlet
                    const outletIndex = database.outlets.findIndex(o => o.id === editingId);
                    if (outletIndex !== -1) {
                        database.outlets[outletIndex].name = name;
                        database.outlets[outletIndex].location = location;
                        
                        // Save to Supabase or local storage
                        await saveOutlet(database.outlets[outletIndex]);
                        
                        showNotification('Outlet updated successfully', 'success');
                    }
                } else {
                    // Add new outlet
                    const newOutlet = {
                        id: database.outlets.length > 0 ? Math.max(...database.outlets.map(o => o.id)) + 1 : 1,
                        name: name,
                        location: location
                    };
                    database.outlets.push(newOutlet);
                    
                    // Save to Supabase or local storage
                    await saveOutlet(newOutlet);
                    
                    showNotification('Outlet created successfully', 'success');
                }
                
                outletForm.style.display = 'none';
                saveToLocalStorage();
                loadOutlets();
                loadOrders();
            });
            
            cancelOutletBtn.addEventListener('click', () => {
                outletForm.style.display = 'none';
            });
            
            // User form handlers (admin only)
            addUserBtn.addEventListener('click', () => {
                if (currentUser.role !== 'admin') return;
                editingId = null;
                userFormTitle.textContent = 'Add New User';
                userForm.style.display = 'block';
                newUserName.value = '';
                newUserUsername.value = '';
                newUserPassword.value = '';
                // Make sure outlets are loaded before setting default value
                if (database.outlets.length > 0) {
                    newUserOutlet.value = database.outlets[0].id;
                }
            });

        saveUserBtn.addEventListener('click', async () => {
            if (currentUser.role !== 'admin') return;
            
            const name = newUserName.value.trim();
            const username = newUserUsername.value.trim();
            const password = newUserPassword.value;
            const outletId = parseInt(newUserOutlet.value);
            
            console.log('Saving user with data:', { name, username, password, outletId }); // Debug
            
            if (!name || !username || !password || !outletId) {
                showNotification('Please fill all required fields', 'error');
                return;
            }
            
            // Validate outlet exists
            const outletExists = database.outlets.some(outlet => outlet.id === outletId);
            if (!outletExists) {
                showNotification('Selected outlet does not exist', 'error');
                return;
            }
            
            // Check if username already exists (exclude current editing user)
            const existingUser = database.users.find(u => 
                u.username.toLowerCase() === username.toLowerCase() && u.id !== editingId
            );
            if (existingUser) {
                showNotification('Username already exists', 'error');
                return;
            }
            
            try {
                if (editingId) {
                    // Update existing user
                    const userIndex = database.users.findIndex(u => u.id === editingId);
                    if (userIndex !== -1) {
                        // Update the user object
                        const updatedUser = {
                            ...database.users[userIndex],
                            name: name,
                            username: username,
                            password: password,
                            outlet_id: outletId,
                            // Remove outletId field to avoid confusion
                        };
                        delete updatedUser.outletId; // Remove old field
                        
                        database.users[userIndex] = updatedUser;
                        console.log('Updated user:', database.users[userIndex]);
                        
                        // Save to Supabase or local storage
                        await saveUser(updatedUser);
                        showNotification('User updated successfully', 'success');
                    }
                } else {
                    // Add new user
                    const newUser = {
                        id: Math.max(0, ...database.users.map(u => u.id || 0)) + 1,
                        name: name,
                        username: username,
                        password: password,
                        outlet_id: outletId,
                        role: 'user'
                    };
                    
                    console.log('Creating new user:', newUser);
                    database.users.push(newUser);
                    
                    // Save to Supabase or local storage
                    await saveUser(newUser);
                    showNotification('User created successfully', 'success');
                }
                
                userForm.style.display = 'none';
                saveToLocalStorage();
                
                // Force reload users to ensure display is updated
                await loadUsers();
                
            } catch (error) {
                console.error('Error saving user:', error);
                showNotification('Error saving user: ' + error.message, 'error');
            }
        });
            
            // Edit and delete handlers for items (admin only)
            itemsList.addEventListener('click', (e) => {
                if (currentUser.role !== 'admin') return;
                
                if (e.target.classList.contains('edit-item') || e.target.parentElement.classList.contains('edit-item')) {
                    const itemId = parseInt(e.target.getAttribute('data-id') || e.target.parentElement.getAttribute('data-id'));
                    const item = database.items.find(i => i.id === itemId);
                    
                    if (item) {
                        editingId = itemId;
                        itemFormTitle.textContent = 'Edit Item';
                        itemName.value = item.name;
                        itemCategory.value = item.category;
                        itemUnit.value = item.unit;
                        itemForm.style.display = 'block';
                    }
                }
                
                if (e.target.classList.contains('delete-item') || e.target.parentElement.classList.contains('delete-item')) {
                    const itemId = parseInt(e.target.getAttribute('data-id') || e.target.parentElement.getAttribute('data-id'));
                    
                    // Check if button is disabled
                    const button = e.target.classList.contains('delete-item') ? e.target : e.target.parentElement;
                    if (button.disabled) {
                        showNotification('This item cannot be deleted because it is used in existing orders', 'error');
                        return;
                    }
                    
                    deleteItem(itemId);
                }
            });
            
            // Edit and delete handlers for outlets (admin only)
            outletsList.addEventListener('click', (e) => {
                if (currentUser.role !== 'admin') return;
                
                if (e.target.classList.contains('edit-outlet') || e.target.parentElement.classList.contains('edit-outlet')) {
                    const outletId = parseInt(e.target.getAttribute('data-id') || e.target.parentElement.getAttribute('data-id'));
                    const outlet = database.outlets.find(o => o.id === outletId);
                    
                    if (outlet) {
                        editingId = outletId;
                        outletFormTitle.textContent = 'Edit Outlet';
                        outletName.value = outlet.name;
                        outletLocation.value = outlet.location;
                        outletForm.style.display = 'block';
                    }
                }
                
                if (e.target.classList.contains('delete-outlet') || e.target.parentElement.classList.contains('delete-outlet')) {
                    const outletId = parseInt(e.target.getAttribute('data-id') || e.target.parentElement.getAttribute('data-id'));
                    deleteOutlet(outletId);
                }
            });
            
            // Edit and delete handlers for users (admin only)
            userList.addEventListener('click', async (e) => { 
                if (currentUser.role !== 'admin') return;
                
                // In the userList event listener, update the edit section:
                if (e.target.classList.contains('edit-user') || e.target.parentElement.classList.contains('edit-user')) {
                    const userId = parseInt(e.target.getAttribute('data-id') || e.target.parentElement.getAttribute('data-id'));
                    const user = database.users.find(u => u.id === userId);
                    
                    if (user) {
                        // Ensure outlets are loaded before showing form
                        const outletsLoaded = await ensureOutletsLoaded();
                        if (!outletsLoaded) {
                            return;
                        }
                        
                        editingId = userId;
                        userFormTitle.textContent = 'Edit User';
                        newUserName.value = user.name;
                        newUserUsername.value = user.username;
                        newUserPassword.value = user.password;
                        
                        // Use the populateOutletDropdown function
                        const outletId = user.outlet_id || user.outletId;
                        populateOutletDropdown(newUserOutlet, outletId);
                        
                        userForm.style.display = 'block';
                    }
                }
                
                // Delete user handler (keep this part as is)
                if (e.target.classList.contains('delete-user') || e.target.parentElement.classList.contains('delete-user')) {
                    const userId = parseInt(e.target.getAttribute('data-id') || e.target.parentElement.getAttribute('data-id'));
                    
                    if (userId === currentUser.id) {
                        showNotification('You cannot delete your own account', 'error');
                        return;
                    }
                    
                    deleteUser(userId);
                }
            });

            // Update quantity in cart
            cartItems.addEventListener('change', (e) => {
                if (e.target.classList.contains('quantity-input')) {
                    const itemId = parseInt(e.target.getAttribute('data-id'));
                    const newQuantity = parseFloat(e.target.value);
                    
                    if (newQuantity <= 0) {
                        // Remove item if quantity is 0 or negative
                        cart = cart.filter(item => item.id !== itemId);
                        showNotification('Item removed from cart', 'success');
                    } else {
                        // Update quantity
                        const cartItem = cart.find(item => item.id === itemId);
                        if (cartItem) {
                            cartItem.quantity = newQuantity;
                        }
                    }
                    
                    updateCart();
                }
            });
            
            // Remove item from cart
            cartItems.addEventListener('click', (e) => {
                if (e.target.classList.contains('remove-item') || e.target.parentElement.classList.contains('remove-item')) {
                    const itemId = parseInt(e.target.getAttribute('data-id') || e.target.parentElement.getAttribute('data-id'));
                    cart = cart.filter(item => item.id !== itemId);
                    updateCart();
                    showNotification('Item removed from cart', 'success');
                }
            });
        }

        // Initialize the app
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
